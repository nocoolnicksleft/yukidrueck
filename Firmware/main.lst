CCS PCM C Compiler, Version 4.069, 38648               08-Mai-10 21:46

               Filename: main.lst

               ROM used: 4279 words (52%)
                         Largest free fragment is 2048
               RAM used: 278 (76%) at main() level
                         313 (85%) worst case
               Stack:    7 worst case (6 in main + 1 for interrupts)

*
0000:  MOVLW  10
0001:  MOVWF  0A
0002:  GOTO   000
0003:  NOP
0004:  MOVWF  7F
0005:  SWAPF  03,W
0006:  CLRF   03
0007:  MOVWF  21
0008:  MOVF   0A,W
0009:  MOVWF  20
000A:  CLRF   0A
000B:  MOVF   04,W
000C:  MOVWF  22
000D:  MOVF   77,W
000E:  MOVWF  23
000F:  MOVF   78,W
0010:  MOVWF  24
0011:  MOVF   79,W
0012:  MOVWF  25
0013:  MOVF   7A,W
0014:  MOVWF  26
0015:  MOVF   7B,W
0016:  MOVWF  27
0017:  BCF    03.7
0018:  BCF    03.5
0019:  BTFSS  0B.4
001A:  GOTO   01D
001B:  BTFSC  0B.1
001C:  GOTO   03C
001D:  MOVLW  8C
001E:  MOVWF  04
001F:  BTFSS  00.5
0020:  GOTO   023
0021:  BTFSC  0C.5
0022:  GOTO   03F
0023:  MOVLW  8C
0024:  MOVWF  04
0025:  BTFSS  00.0
0026:  GOTO   029
0027:  BTFSC  0C.0
0028:  GOTO   042
0029:  MOVF   22,W
002A:  MOVWF  04
002B:  MOVF   23,W
002C:  MOVWF  77
002D:  MOVF   24,W
002E:  MOVWF  78
002F:  MOVF   25,W
0030:  MOVWF  79
0031:  MOVF   26,W
0032:  MOVWF  7A
0033:  MOVF   27,W
0034:  MOVWF  7B
0035:  MOVF   20,W
0036:  MOVWF  0A
0037:  SWAPF  21,W
0038:  MOVWF  03
0039:  SWAPF  7F,F
003A:  SWAPF  7F,W
003B:  RETFIE
003C:  BCF    0A.3
003D:  BCF    0A.4
003E:  GOTO   148
003F:  BCF    0A.3
0040:  BCF    0A.4
0041:  GOTO   110
0042:  BCF    0A.3
0043:  BCF    0A.4
0044:  GOTO   0DA
.................... #include <16F877.h> 
.................... //////// Standard Header file for the PIC16F877 device //////////////// 
.................... #device PIC16F877 
.................... #list 
....................  
....................  
.................... #fuses HS,NOWDT,NOPROTECT,PUT,NOBROWNOUT,NOLVP 
....................  
.................... #include <stdlib.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2007 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDLIB 
.................... #define _STDLIB 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Definitions and types 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #ifndef RAND_MAX 
.................... #define RAND_MAX  32767    // The value of which is the maximum value 
....................                            // ... returned by the rand function 
.................... #endif 
....................  
....................  
.................... #IF (sizeof(int16*)>1) 
.................... #DEFINE LONG_POINTERS 1 
.................... #ELSE  
.................... #DEFINE LONG_POINTERS 0 
.................... #ENDIF 
....................  
.................... typedef struct { 
....................    signed int quot; 
....................    signed int rem; 
.................... } div_t; 
....................  
.................... typedef struct { 
....................    signed long quot; 
....................    signed long rem; 
.................... } ldiv_t; 
....................  
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #define size_t unsigned int8 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
....................  
.................... //--------------------------------------------------------------------------- 
.................... // String conversion functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* Standard template: float32 atof(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... float atof(char * s); 
....................  
....................  
.................... #if defined(__PCD__) 
....................  
.................... /* Standard template:  atof(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... float32 atof(char * s); 
.................... // The following functions only work on the 24 bit compiler 
.................... // for the 30F, 33F, 24F and 24H parts 
....................  
.................... /* Standard template: float48 atof48(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... float48 atof48(char * s); 
....................  
.................... /* Standard template: float64 atof64(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... float64 atof64(char * s); 
.................... #endif 
....................  
.................... /* Standard template: float32 atoe(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  * also handles E format numbers 
....................  */ 
.................... #if !defined(__PCD__) 
.................... float atoe(char * s); 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
.................... float32 atoe(char * s); 
.................... #endif 
....................  
.................... /* Standard template: signed int  atoi(char * s) 
....................  * converts the initial portion of the string s to a signed int 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... signed int atoi(char *s); 
....................  
.................... /* Syntax: signed int32  atoi32(char * s) 
....................    converts the initial portion of the string s to a signed int32 
....................    returns the converted value if any, 0 otherwise*/ 
.................... #if (sizeof(long)==4) 
....................  #define atoi32(s) atol(s) 
.................... #else  
....................  signed int32 atoi32(char *s); 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
.................... // The following functions only work on the 24 bit compiler 
.................... // for the 30F, 33F, 24F and 24H parts 
.................... /* Syntax: signed int48  atoi48(char * s) 
....................    converts the initial portion of the string s to a signed int48 
....................    returns the converted value if any, 0 otherwise*/ 
....................     
.................... signed int48 atoi48(char *s); 
....................  
.................... /* Syntax: signed int64  atoi64(char * s) 
....................    converts the initial portion of the string s to a signed int64 
....................    returns the converted value if any, 0 otherwise*/ 
.................... signed int64 atoi64(char *s); 
.................... #endif 
....................  
.................... /* Syntax: char *  itoa(signed int32 num, int8 base, char * s) 
....................    converts the signed int32 to a string and 
....................    returns the converted value if any, 0 otherwise*/ 
.................... char * itoa(signed int32 num, unsigned int base, char * s); 
....................  
.................... /* Standard template: signed int16  atol(char * s) 
....................  * converts the initial portion of the string s to a signed int16 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... signed long atol(char *s); 
....................  
.................... /* Standard template: float32 strtod(char * s,char *endptr) 
....................  * converts the initial portion of the string s to a float32 
....................  * returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null 
....................  */ 
....................  // This function is called strtod in PCM/PCH 
....................  // This ensures compatibility between compilers 
.................... #if !defined(__PCD__) 
.................... float strtod(char *s,char *endptr);  
.................... #endif 
....................  
.................... /* Standart template: float32 strto(char * s,char *endptr) 
....................                       float48 strtof48(char *s,char *endptr); 
....................                       float64 strtod(char *s,char *endptr); 
....................  * converts the initial portion of the string s to a float32, float48 or float64, 
....................  * returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null                    
.................... */ 
.................... #if defined(__PCD__) 
.................... float32 strtof(char *s,char *endptr); 
.................... float48 strtof48(char *s,char *endptr); 
.................... float64 strtod(char *s,char *endptr); 
.................... #endif 
....................  
.................... /* Standard template: int16 strtoul(char * s,char *endptr,signed int base) 
....................  * converts the initial portion of the string s, represented as an 
....................  * integral value of radix base  to a signed long. 
....................  * Returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null 
....................  */ 
.................... signed long strtol(char *s,char *endptr, signed int base); 
....................  
.................... /* Standard template: int16 strtoul(char * s,char *endptr,signed int base) 
....................  * converts the initial portion of the string s, represented as an 
....................  * integral value of radix base to a unsigned long. 
....................  * returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null 
....................  */ 
.................... unsigned long strtoul(char *s,char *endptr, signed int base); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Pseudo-random sequence generation functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* The rand function computes a sequence of pseudo-random integers in 
....................  * the range 0 to RAND_MAX 
....................  * 
....................  * Parameters: 
....................  *       (none) 
....................  * 
....................  * Returns: 
....................  *       The pseudo-random integer 
....................  */ 
.................... unsigned int16 rand(void); 
....................  
.................... /* The srand function uses the argument as a seed for a new sequence of 
....................  * pseudo-random numbers to be returned by subsequent calls to rand. 
....................  * 
....................  * Parameters: 
....................  *       [in] seed: The seed value to start from. You might need to pass 
....................  * 
....................  * Returns: 
....................  *       (none) 
....................  * 
....................  * Remarks 
....................  *          The srand function sets the starting point for generating 
....................  *       a series of pseudorandom integers. To reinitialize the 
....................  *       generator, use 1 as the seed argument. Any other value for 
....................  *       seed sets the generator to a random starting point. rand 
....................  *       retrieves the pseudorandom numbers that are generated. 
....................  *       Calling rand before any call to srand generates the same 
....................  *       sequence as calling srand with seed passed as 1. 
....................  *          Usually, you need to pass a time here from outer source 
....................  *       so that the numbers will be different every time you run. 
....................  */ 
.................... void srand(unsigned int32 seed); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Memory management functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Comming soon 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Communication with the environment 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* The function returns 0 always 
....................  */ 
.................... signed int8 system(char *string); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Searching and sorting utilities 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* Performs a binary search of a sorted array.. 
....................  * 
....................  * Parameters: 
....................  *       [in] key: Object to search for 
....................  *       [in] base: Pointer to base of search data 
....................  *       [in] num: Number of elements 
....................  *       [in] width: Width of elements 
....................  *       [in] compare: Function that compares two elements 
....................  * 
....................  * Returns: 
....................  *       bsearch returns a pointer to an occurrence of key in the array pointed 
....................  *       to by base. If key is not found, the function returns NULL. If the 
....................  *       array is not in order or contains duplicate records with identical keys, 
....................  *       the result is unpredictable. 
....................  */ 
.................... //void *bsearch(const void *key, const void *base, size_t num, size_t width, 
.................... //              int (*compare)(const void *, const void *)); 
....................  
.................... /* Performs the shell-metzner sort (not the quick sort algorithm). The contents 
....................  * of the array are sorted into ascending order according to a comparison 
....................  * function pointed to by compar. 
....................  * 
....................  * Parameters: 
....................  *       [in] base: Pointer to base of search data 
....................  *       [in] num: Number of elements 
....................  *       [in] width: Width of elements 
....................  *       [in] compare: Function that compares two elements 
....................  * 
....................  * Returns: 
....................  *       (none) 
....................  */ 
.................... //void *qsort(const void *base, size_t num, size_t width, 
.................... //              int (*compare)(const void *, const void *)); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Integer arithmetic functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #define labs abs 
....................  
.................... div_t div(signed int numer, signed int denom); 
.................... ldiv_t ldiv(signed long numer, signed long denom); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Multibyte character functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Not supported 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Multibyte string functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Not supported 
....................  
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Internal implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #define size_t unsigned int8 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
.................... #include <string.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #define size_t unsigned int8 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
.................... #include <ctype.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _CTYPE 
.................... #define _CTYPE 
....................  
.................... #define islower(x)  isamong(x,"abcdefghijklmnopqrstuvwxyz") 
.................... #define isupper(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZ") 
.................... #define isalnum(x)  isamong(x,"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isalpha(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isdigit(x)  isamong(x,"0123456789") 
.................... #define isspace(x)  ((x)==' ') 
.................... #define isxdigit(x) isamong(x,"0123456789ABCDEFabcdef") 
.................... #define iscntrl(x)  ((x)<' ') 
.................... #define isprint(x)  ((x)>=' ') 
.................... #define isgraph(x)  ((x)>' ') 
.................... #define ispunct(x)  (((x)>' ')&&!isalnum(x)) 
....................  
.................... #endif 
....................  
....................  
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *memmove(void *s1,char *s2,size_t n) 
.................... { 
....................    char *sc1; 
....................    char *sc2; 
....................    sc1=s1; 
....................    sc2=s2; 
....................    if(sc2<sc1 && sc1 <sc2 +n) 
....................       for(sc1+=n,sc2+=n;0<n;--n) 
....................          *--sc1=*--sc2; 
....................    else 
....................       for(;0<n;--n) 
....................          *sc1++=*sc2++; 
....................   return s1; 
....................   } 
....................  
.................... /* compiler ignored the name 'strcpy()'; perhaps, it's reserved? 
....................    Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1*/ 
....................  
.................... char *strcopy(char *s1, char *s2) 
.................... { 
....................   char *s; 
....................  
....................   for (s = s1; *s2 != 0; s++, s2++) { 
....................      *s = *s2; 
....................   } 
....................   *s = *s2; 
....................   return(s1); 
.................... } 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *strncpy(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(s1); 
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... char *strcat(char *s1, char *s2) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0') 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... char *strncat(char *s1, char *s2, size_t n) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0' && 0<n) 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................       --n; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 memcmp(void * s1,char *s2,size_t n) 
.................... { 
.................... char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
.................... { 
....................    if(*su1!=*su2) 
....................       return ((*su1<*su2)?-1:+1); 
.................... } 
.................... return 0; 
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcmp(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcoll(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int8 strncmp(char *s1, char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
....................       if (*s1 != *s2) 
....................          return((*s1 <*s2) ? -1: 1); 
....................       else if (*s1 == '\0') 
....................          return(0); 
....................    return(0); 
.................... } 
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1*/ 
.................... size_t strxfrm(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................   unsigned int8 n1; 
....................   n1=n; 
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... char *memchr(void *s,unsigned int8 c,size_t n) 
.................... { 
....................    char uc; 
....................    char *su; 
....................    uc=c; 
....................    for(su=s;0<n;++su,--n) 
....................       if(*su==uc) 
....................       return su; 
....................    return NULL; 
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... char *strchr(char *s, unsigned int8 c) 
.................... { 
....................    for (; *s != c; s++) 
....................       if (*s == '\0') 
....................          return(0); 
....................    return(s); 
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... unsigned int8 *strcspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... char *strpbrk(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1); 
....................    return(0); 
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... char *strrchr(char *s, unsigned int8 c) 
.................... { 
....................    char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... unsigned int8 *strspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; ; sc2++) 
....................     if (*sc2 == '\0') 
....................        return(sc1 - s1); 
....................          else if (*sc1 == *sc2) 
....................             break; 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... char *strstr(char *s1, char *s2) 
.................... { 
....................    char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
....................  
....................       if (*t == '\0') 
....................          return s1; 
....................       ++s1; 
....................       #ifdef FASTER_BUT_MORE_ROM 
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... char *strtok(char *s1, char *s2) 
.................... { 
....................    char *beg, *end; 
....................    static char *save; 
*
1011:  BCF    03.5
1012:  CLRF   28
1013:  CLRF   29
....................  
....................    beg = (s1)? s1: save; 
....................    beg += strspn(beg, s2); 
....................    if (*beg == '\0') 
....................    { 
....................       *save = ' '; 
....................       return(0); 
....................    } 
....................    end = strpbrk(beg, s2); 
....................    if (*end != '\0') 
....................    { 
....................       *end = '\0'; 
....................       end++; 
....................    } 
....................    save = end; 
....................    return(beg); 
.................... } 
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... char * strerror(unsigned int8 errnum) 
.................... { 
.................... char s[15]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... unsigned int8 *strlen(char *s) 
.................... { 
....................    char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
....................    return(sc - s); 
.................... } 
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int8 stricmp(char *s1, char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
....................        return(0); 
....................  return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strlwr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
....................  
.................... div_t div(signed int numer, signed int denom) 
.................... { 
....................    div_t val; 
....................    val.quot = numer / denom; 
....................    val.rem = numer - (denom * val.quot); 
....................    return (val); 
.................... } 
....................  
.................... ldiv_t ldiv(signed long numer, signed long denom) 
.................... { 
....................    ldiv_t val; 
....................    val.quot = numer / denom; 
....................    val.rem = numer - (denom * val.quot); 
....................    return (val); 
.................... } 
.................... #if !defined(__PCD__) 
....................  
.................... float atof(char * s) 
.................... { 
....................    float pow10 = 1.0; 
....................    float result = 0.0; 
....................    unsigned int8 sign = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    c = s[ptr++]; 
....................  
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.') { 
....................       if(c == '-') { 
....................          sign = 1; 
....................          c = s[ptr++]; 
....................       } 
....................       if(c == '+') 
....................          c = s[ptr++]; 
....................  
....................       while((c >= '0' && c <= '9')) { 
....................          result = 10*result + c - '0'; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '.') { 
....................          c = s[ptr++]; 
....................          while((c >= '0' && c <= '9')) { 
....................              pow10 = pow10*10; 
....................              result += (c - '0')/pow10; 
....................              c = s[ptr++]; 
....................          } 
....................       } 
....................  
....................    } 
....................  
....................    if (sign == 1) 
....................       result = -1*result; 
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
.................... float32 atof(char * s) 
.................... { 
....................    float32 pow10 = 1.0; 
....................    float32 result = 0.0; 
....................    unsigned int8 sign = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    c = s[ptr++]; 
....................  
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.') { 
....................       if(c == '-') { 
....................          sign = 1; 
....................          c = s[ptr++]; 
....................       } 
....................       if(c == '+') 
....................          c = s[ptr++]; 
....................  
....................       while((c >= '0' && c <= '9')) { 
....................          result = 10*result + c - '0'; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '.') { 
....................          c = s[ptr++]; 
....................          while((c >= '0' && c <= '9')) { 
....................              pow10 = pow10*10; 
....................              result += (c - '0')/pow10; 
....................              c = s[ptr++]; 
....................          } 
....................       } 
....................  
....................    } 
....................  
....................    if (sign == 1) 
....................       result = -1*result; 
....................    return(result); 
.................... } 
....................  
....................  
....................  
.................... float48 atof48(char * s) 
.................... { 
....................    float48 pow10 = 1.0; 
....................    float48 result = 0.0; 
....................    unsigned int8 sign = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    c = s[ptr++]; 
....................  
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.') { 
....................       if(c == '-') { 
....................          sign = 1; 
....................          c = s[ptr++]; 
....................       } 
....................       if(c == '+') 
....................          c = s[ptr++]; 
....................  
....................       while((c >= '0' && c <= '9')) { 
....................          result = 10*result + c - '0'; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '.') { 
....................          c = s[ptr++]; 
....................          while((c >= '0' && c <= '9')) { 
....................              pow10 = pow10*10;  
....................              result += (c - '0')/pow10; 
....................              c = s[ptr++]; 
....................          } 
....................       } 
....................  
....................    } 
....................  
....................    if (sign == 1) 
....................       result = -1*result; 
....................    return(result); 
.................... } 
....................  
.................... float64 atof64(char * s) 
.................... { 
....................    float64 pow10 = 1.0; 
....................    float64 result = 0.0; 
....................    unsigned int8 sign = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    c = s[ptr++]; 
....................  
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.') { 
....................       if(c == '-') { 
....................          sign = 1; 
....................          c = s[ptr++]; 
....................       } 
....................       if(c == '+') 
....................          c = s[ptr++]; 
....................  
....................       while((c >= '0' && c <= '9')) { 
....................          result = 10*result + c - '0'; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '.') { 
....................          c = s[ptr++]; 
....................          while((c >= '0' && c <= '9')) { 
....................              pow10 = pow10*10; 
....................              result += (c - '0')/pow10; 
....................              c = s[ptr++]; 
....................          } 
....................       } 
....................  
....................    } 
....................  
....................    if (sign == 1) 
....................       result = -1*result; 
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
.................... float32 atoe(char * s) 
.................... { 
....................    float32 pow10 = 1.0; 
....................    float32 result = 0.0; 
....................    unsigned int8 sign = 0; 
....................    unsigned int8 expsign = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................    unsigned int8 i; 
....................    float32 exp = 1.0; 
....................    unsigned int8 expcnt = 0; 
....................  
....................    c = s[ptr++]; 
....................  
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.' || c=='E' || c=='e') { 
....................       if(c == '-') { 
....................          sign = 1; 
....................          c = s[ptr++]; 
....................       } 
....................       if(c == '+') 
....................          c = s[ptr++]; 
....................  
....................       while((c >= '0' && c <= '9')) { 
....................          result = 10*result + c - '0'; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '.') { 
....................          c = s[ptr++]; 
....................          while((c >= '0' && c <= '9')) { 
....................              pow10 = pow10*10; 
....................              result += (c - '0')/pow10; 
....................              c = s[ptr++]; 
....................          } 
....................       } 
....................  
....................       // Handling the exponent 
....................       if (c=='e' || c=='E') { 
....................          c = s[ptr++]; 
....................  
....................          if(c == '-') { 
....................             expsign = 1; 
....................             c = s[ptr++]; 
....................          } 
....................          if(c == '+') 
....................             c = s[ptr++]; 
....................  
....................          while((c >= '0' && c <= '9')) { 
....................             expcnt = 10*expcnt + c - '0'; 
....................             c = s[ptr++]; 
....................          } 
....................  
....................          for(i=0;i<expcnt;i++) 
....................             exp*=10; 
....................  
....................          if(expsign==1) 
....................             result/=exp; 
....................          else 
....................             result*=exp; 
....................       } 
....................    } 
....................  
....................    if (sign == 1) 
....................       result = -1*result; 
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... #if !defined(__PCD__) 
.................... float atoe(char * s) 
.................... { 
....................    float pow10 = 1.0; 
....................    float result = 0.0; 
....................    unsigned int8 sign = 0; 
....................    unsigned int8 expsign = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................    unsigned int8 i; 
....................    float exp = 1.0; 
....................    unsigned int8 expcnt = 0; 
....................  
....................    c = s[ptr++]; 
....................  
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.' || c=='E' || c=='e') { 
....................       if(c == '-') { 
....................          sign = 1; 
....................          c = s[ptr++]; 
....................       } 
....................       if(c == '+') 
....................          c = s[ptr++]; 
....................  
....................       while((c >= '0' && c <= '9')) { 
....................          result = 10*result + c - '0'; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '.') { 
....................          c = s[ptr++]; 
....................          while((c >= '0' && c <= '9')) { 
....................              pow10 = pow10*10; 
....................              result += (c - '0')/pow10; 
....................              c = s[ptr++]; 
....................          } 
....................       } 
....................  
....................       // Handling the exponent 
....................       if (c=='e' || c=='E') { 
....................          c = s[ptr++]; 
....................  
....................          if(c == '-') { 
....................             expsign = 1; 
....................             c = s[ptr++]; 
....................          } 
....................          if(c == '+') 
....................             c = s[ptr++]; 
....................  
....................          while((c >= '0' && c <= '9')) { 
....................             expcnt = 10*expcnt + c - '0'; 
....................             c = s[ptr++]; 
....................          } 
....................  
....................          for(i=0;i<expcnt;i++) 
....................             exp*=10; 
....................  
....................          if(expsign==1) 
....................             result/=exp; 
....................          else 
....................             result*=exp; 
....................       } 
....................    } 
....................  
....................    if (sign == 1) 
....................       result = -1*result; 
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... signed int atoi(char *s) 
.................... { 
....................    signed int result; 
....................    unsigned int sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    // Omit all preceeding alpha characters 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................  
....................       // Check for hexa number 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') 
....................          { 
....................             result = 10*result + (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ( (c >= '0' && c <= '9') || (c >= 'A' && c<='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++]; 
....................             c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (sign == 1 && base == 10) 
....................        result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... signed long atol(char *s) 
.................... { 
....................    signed long result; 
....................    unsigned int sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') 
....................          { 
....................             result = 10*result + (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ( (c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... /* A fast routine to multiply by 10 
....................  */ 
.................... signed int32 mult_with10(int32 num) 
.................... { 
....................    return ( (num << 1) + (num << 3) ); 
.................... } 
....................  
.................... #if sizeof(long)==2 
.................... signed int32 atoi32(char *s) 
.................... { 
....................    signed int32 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
....................  
.................... signed int48 atoi48(char *s) 
.................... { 
....................    signed int48 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... signed int64 atoi64(char *s) 
.................... { 
....................    signed int64 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... char * itoa(signed int32 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int32 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................  
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1; 
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................  
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... #if !defined(__PCD__) 
.................... float strtod(char *s,char *endptr) { 
....................    float pow10 = 1.0; 
....................    float result = 0.0; 
....................    unsigned int8 sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c=s[ptr++]; 
....................  
....................  
....................    while((c>='0' && c<='9') || c=='+' || c=='-' || c=='.') { 
....................       if(c == '-') { 
....................          sign = 1; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       while((c >= '0' && c <= '9') && point == 0) { 
....................          result = 10*result + c - '0'; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '.') { 
....................          point = 1; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       while((c >= '0' && c <= '9') && point == 1) { 
....................          pow10 = pow10*10; 
....................          result += (c - '0')/pow10; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '+') { 
....................          c = s[ptr++]; 
....................       } 
....................    } 
....................  
....................    if (sign == 1) 
....................       result = -1*result; 
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((long *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((long *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
.................... float32 strtof(char *s,char *endptr) 
.................... { 
....................    float32 pow10 = 1.0; 
....................    float32 result = 0.0; 
....................    unsigned int8 sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c=s[ptr++]; 
....................  
....................  
....................    while((c>='0' && c<='9') || c=='+' || c=='-' || c=='.') { 
....................       if(c == '-') { 
....................          sign = 1; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       while((c >= '0' && c <= '9') && point == 0) { 
....................          result = 10*result + c - '0'; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '.') { 
....................          point = 1; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       while((c >= '0' && c <= '9') && point == 1) { 
....................          pow10 = pow10*10; 
....................          result += (c - '0')/pow10; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '+') { 
....................          c = s[ptr++]; 
....................       } 
....................    } 
....................  
....................    if (sign == 1) 
....................       result = -1*result; 
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((long *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((long *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
....................  
.................... float48 strtof48(char *s,char *endptr) 
.................... { 
....................    float48 pow10 = 1.0; 
....................    float48 result = 0.0; 
....................    unsigned int8 sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c=s[ptr++]; 
....................  
....................  
....................    while((c>='0' && c<='9') || c=='+' || c=='-' || c=='.') { 
....................       if(c == '-') { 
....................          sign = 1; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       while((c >= '0' && c <= '9') && point == 0) { 
....................          result = 10*result + c - '0'; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '.') { 
....................          point = 1; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       while((c >= '0' && c <= '9') && point == 1) { 
....................          pow10 = pow10*10; 
....................          result += (c - '0')/pow10; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '+') { 
....................          c = s[ptr++]; 
....................       } 
....................    } 
....................  
....................    if (sign == 1) 
....................       result = -1*result; 
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((long *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((long *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
....................  
.................... float64 strtod(char *s,char *endptr) 
.................... { 
....................    float64 pow10 = 1.0; 
....................    float64 result = 0.0; 
....................    unsigned int8 sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c=s[ptr++]; 
....................  
....................  
....................    while((c>='0' && c<='9') || c=='+' || c=='-' || c=='.') { 
....................       if(c == '-') { 
....................          sign = 1; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       while((c >= '0' && c <= '9') && point == 0) { 
....................          result = 10*result + c - '0'; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '.') { 
....................          point = 1; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       while((c >= '0' && c <= '9') && point == 1) { 
....................          pow10 = pow10*10; 
....................          result += (c - '0')/pow10; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '+') { 
....................          c = s[ptr++]; 
....................       } 
....................    } 
....................  
....................    if (sign == 1) 
....................       result = -1*result; 
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((long *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((long *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... unsigned long strtoul(char *s, char *endptr, signed int base) 
.................... { 
....................    char *sc,*s1,*sd; 
....................    unsigned long x=0; 
....................    char sign; 
....................    char digits[]="0123456789abcdefghijklmnopqstuvwxyz"; 
....................    for(sc=s;isspace(*sc);++sc); 
....................    sign=*sc=='-'||*sc=='+'?*sc++:'+'; 
....................    if(sign=='-' || base <0 || base ==1|| base >36) // invalid base 
....................    goto StrtoulGO; 
....................  
....................    else if (base) 
....................    { 
....................       if(base==16 && *sc =='0'&&(sc[1]=='x' || sc[1]=='X')) 
....................          sc+=2; 
....................       if(base==8 && *sc =='0') 
....................          sc+=1; 
....................       if(base==2 && *sc =='0'&&sc[1]=='b') 
....................          sc+=2; 
....................  
....................    } 
....................    else if(*sc!='0') // base is 0, find base 
....................       base=10; 
....................    else if (sc[1]=='x' || sc[1]=='X') 
....................       base =16,sc+=2; 
....................    else if(sc[1]=='b') 
....................       base=2,sc+=2; 
....................    else 
....................       base=8; 
....................    for (s1=sc;*sc=='0';++sc);// skip leading zeroes 
....................    sd=memchr(digits,tolower(*sc),base); 
....................    for(; sd!=0; ) 
....................    { 
....................       x=x*base+(int16)(sd-digits); 
....................       ++sc; 
....................       sd=memchr(digits,tolower(*sc),base); 
....................    } 
....................    if(s1==sc) 
....................    { 
....................    StrtoulGO: 
....................       if (endptr) 
....................       { 
....................          #IF LONG_POINTERS 
....................          *((long *)endptr)= s;  
....................          #ELSE 
....................          *((char *)endptr)=s; 
....................          #ENDIF 
....................          } 
....................    return 0; 
....................    } 
....................    if (endptr) 
....................    { 
....................          #IF LONG_POINTERS 
....................          *((long *)endptr)= sc;  
....................          #ELSE 
....................          *((char *)endptr)=sc;  
....................          #ENDIF 
....................    } 
....................    return x; 
.................... } 
....................  
....................  
.................... signed long strtol(char *s,char *endptr, signed int base) 
.................... { 
....................    char *sc,*s1,*sd; 
....................    signed long x=0; 
....................    char sign; 
....................    char digits[]="0123456789abcdefghijklmnopqstuvwxyz"; 
....................    for(sc=s;isspace(*sc);++sc); 
....................    sign=*sc=='-'||*sc=='+'?*sc++:'+'; 
....................    if (base <0 || base ==1|| base >36) // invalid base 
....................    goto StrtolGO; 
....................    else if (base) 
....................    { 
....................       if(base==16 && *sc =='0'&&(sc[1]=='x' || sc[1]=='X')) 
....................          sc+=2; 
....................       if(base==8 && *sc =='0') 
....................          sc+=1; 
....................       if(base==2 && *sc =='0'&&sc[1]=='b') 
....................          sc+=2; 
....................  
....................    } 
....................    else if(*sc!='0') // base is 0, find base 
....................       base=10; 
....................    else if (sc[1]=='x' || sc[1]=='X') 
....................       base =16,sc+=2; 
....................    else if(sc[1]=='b') 
....................       base=2,sc+=2; 
....................    else 
....................       base=8; 
....................    for (s1=sc;*sc=='0';++sc);// skip leading zeroes 
....................  
....................    sd=memchr(digits,tolower(*sc),base); 
....................    for(;sd!=0;) 
....................    { 
....................       x=x*base+(int16)(sd-digits); 
....................       ++sc; 
....................       sd=memchr(digits,tolower(*sc),base); 
....................    } 
....................    if(s1==sc) 
....................    { 
....................    StrtolGO: 
....................       if (endptr) 
....................       { 
....................          #IF LONG_POINTERS 
....................          *((long *)endptr)= s;  
....................          #ELSE 
....................          *((char *)endptr)=s; 
....................          #ENDIF 
....................       } 
....................    return 0; 
....................    } 
....................    if(sign=='-') 
....................       x  =-x; 
....................    if (endptr) 
....................    { 
....................         #IF LONG_POINTERS 
....................          *((long *)endptr)= sc;  
....................         #ELSE 
....................         *((char *)endptr)=sc; 
....................         #ENDIF 
....................    } 
....................    return x; 
.................... } 
....................  
.................... signed int8 system(char *string) 
.................... { 
....................    return 0; 
.................... } 
....................  
.................... int8 mblen(char *s,size_t n) 
.................... { 
....................    return strlen(s); 
.................... } 
....................  
.................... int8 mbtowc(wchar_t *pwc,char *s,size_t n) 
.................... { 
....................    *pwc=*s; 
....................    return 1; 
.................... } 
....................  
.................... int8 wctomb(char *s,wchar_t wchar) 
.................... { 
....................    *s=wchar; 
....................    return 1; 
.................... } 
....................  
.................... size_t mbstowcs(wchar_t *pwcs,char *s,size_t n) 
.................... { 
....................    strncpy(pwcs,s,n); 
....................    return strlen(pwcs); 
.................... } 
....................  
.................... size_t wcstombs(char *s,wchar_t *pwcs,size_t n) 
.................... { 
....................    strncpy(s,pwcs,n); 
....................    return strlen(s); 
.................... } 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // The random number implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... unsigned int32 _Randseed; 
....................  
.................... unsigned int16 rand(void) 
.................... { 
....................    _Randseed = _Randseed * 1103515245 + 12345; 
....................    return ((unsigned int16)(_Randseed >> 16) % RAND_MAX); 
.................... } 
....................  
.................... void srand(unsigned int32 seed) 
.................... { 
....................    _Randseed = seed; 
*
0201:  BSF    03.5
0202:  BSF    03.6
0203:  MOVF   22,W
0204:  BCF    03.5
0205:  BCF    03.6
0206:  MOVWF  2D
0207:  BSF    03.5
0208:  BSF    03.6
0209:  MOVF   21,W
020A:  BCF    03.5
020B:  BCF    03.6
020C:  MOVWF  2C
020D:  BSF    03.5
020E:  BSF    03.6
020F:  MOVF   20,W
0210:  BCF    03.5
0211:  BCF    03.6
0212:  MOVWF  2B
0213:  BSF    03.5
0214:  BSF    03.6
0215:  MOVF   1F,W
0216:  BCF    03.5
0217:  BCF    03.6
0218:  MOVWF  2A
.................... } 
0219:  RETLW  00
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Searching and sorting utilities implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #if !defined(__PCD__) 
.................... typedef signed int8 (*_Cmpfun)(char * p1,char * p2);  
.................... #else  
.................... typedef signed int16 (*_Cmpfun)(char * p1,char * p2);  
.................... #endif 
....................  
....................  
....................  
.................... void qsort(char * qdata, unsigned int qitems, unsigned int qsize, _Cmpfun cmp) { 
....................    unsigned int m,j,i,l; 
....................    int1 done; 
....................    BYTE t[16]; 
....................  
....................    m = qitems/2; 
....................    while( m > 0 ) { 
....................      for(j=0; j<(qitems-m); ++j) { 
....................         i = j; 
....................         do 
....................         { 
....................            done=TRUE; 
....................            l = i+m; 
....................            if( (*cmp)(qdata+i*qsize, qdata+l*qsize) > 0 ) { 
....................               memcpy(t, qdata+i*qsize, qsize); 
....................               memcpy(qdata+i*qsize, qdata+l*qsize, qsize); 
....................               memcpy(qdata+l*qsize, t, qsize); 
....................               if(m <= i) 
....................                 i -= m; 
....................                 done = FALSE; 
....................            } 
....................         } while(!done); 
....................      } 
....................      m = m/2; 
....................    } 
.................... } 
....................  
....................  
.................... char *bsearch(char *key, char *base, size_t num, size_t width,_Cmpfun cmp) 
.................... { 
....................    char *p, *q; 
....................    size_t n; 
....................    size_t pivot; 
....................    signed int val; 
....................  
....................    p = base; 
....................    n = num; 
....................  
....................    while (n > 0) 
....................    { 
....................       pivot = n >> 1; 
....................       q = p + width * pivot; 
....................  
....................       val = (*cmp)(key, q); 
....................  
....................       if (val < 0) 
....................          n = pivot; 
....................       else if (val == 0) 
....................          return ((char *)q); 
....................       else { 
....................          p = q + width; 
....................          n -= pivot + 1; 
....................       } 
....................    } 
....................  
....................    return NULL;      // There's no match 
.................... } 
....................  
....................  
.................... #endif 
....................  
....................  
.................... #use delay(clock=20000000) 
*
01CD:  MOVLW  9B
01CE:  MOVWF  04
01CF:  BSF    03.7
01D0:  MOVF   00,W
01D1:  BTFSC  03.2
01D2:  GOTO   1E0
01D3:  MOVLW  06
01D4:  MOVWF  78
01D5:  CLRF   77
01D6:  DECFSZ 77,F
01D7:  GOTO   1D6
01D8:  DECFSZ 78,F
01D9:  GOTO   1D5
01DA:  MOVLW  7B
01DB:  MOVWF  77
01DC:  DECFSZ 77,F
01DD:  GOTO   1DC
01DE:  DECFSZ 00,F
01DF:  GOTO   1D3
01E0:  RETLW  00
....................  
.................... #use fast_io(A) 
.................... #use fast_io(B) 
.................... #use fast_io(C) 
.................... #use fast_io(D) 
.................... #use fast_io(E) 
....................  
.................... // #use rs232(STREAM=DEBUGGER,PARITY=N,BITS=8,BAUD=2400,XMIT=PIN_B3,RCV=PIN_B3) 
.................... #use rs232(stream=mp3player, PARITY=N, baud=9600, xmit=PIN_C6, rcv=PIN_C7, ERRORS) 
*
0110:  BTFSS  0C.5
0111:  GOTO   110
0112:  MOVF   18,W
0113:  MOVWF  2E
0114:  MOVF   1A,W
0115:  MOVWF  78
0116:  BTFSS  2E.1
0117:  GOTO   11A
0118:  BCF    18.4
0119:  BSF    18.4
....................  
.................... /* 
....................  
.................... Illustrationen: 
....................  
.................... KNOPF 5: Schaf 
.................... KNOPF 4: Hund 
.................... KNOPF 3: Pferd 
.................... KNOPF 2: Kuh 
.................... KNOPF 1: Esel 
....................  
....................  
.................... PROGRAMM 1 "FANG DEN FURZ" 
....................  
.................... Die Knpfe leuchten reihum. Drckt man einen Knopf wenn er gerade leuchtet gibts zur Belohnung den Furz. 
....................  
.................... PROGRAMM 2 "BEETHOVEN" 
....................  
.................... Wenn die Knpfe gedrckt werden leuchten sie und die Tne C,D,E,F,G werden bis zum Loslassen gespielt. 
.................... Das reicht leider nicht ganz fr "Alle meine Entchen" 
....................  
.................... PROGRAMM 3 "SENSO" bzw "SIMON" 
....................  
.................... Es wird Folge von Knpfen erleuchtet zu denen jeweils ein Ton gehrt. Die Folge ist nachzuspielen und verlngert sich jedesmal. 
.................... Wird die Ziellnge (5) fehlerfrei nachgespielt gibts frhliche Musik. Sonst den Furz. Am Ende muss das Spiel mit einem 
.................... neuen Druck auf die 3 neu gestartet werden. 
....................  
.................... PROGRAMM 4 "MUH" 
....................  
.................... Jeder Knopf gehrt einem Tier. Es werden die vorhandenen Gerusche fr jedes Tier reihum abgespielt. 
.................... 1: Kuh 2: Esel 3: Frosch 4: Pferd 5: Schaf 
....................  
.................... PROGRAMM 5 
....................  
.................... Lustige Boing/Krach/Peng Gerusche 
....................  
.................... PROGRAMM 6 
....................  
.................... Verschiedene Sorten Klingeln 
....................  
.................... PROGRAMM 7 
....................  
.................... 5 Yuki Top Hits 1 
....................  
.................... PROGRAMM 8 
....................  
.................... 5 Yuki Top Hits 2 
....................  
.................... PROGRAMM 9 
....................  
.................... 5 Yuki Top Hits 3 
....................  
....................  
.................... ? 
....................  
.................... KNOPF "X" schaltet in Sleep-Mode 
....................  
.................... KNOPF "T" sTartet das Programm von vorne 
....................  
.................... */ 
....................  
.................... #define MAX_PROGRAM 12 
....................  
.................... #define KEYLOCK PIN_E0 
.................... #define MP3PLAYERBUSY PIN_B0 
....................  
.................... #define EEPROM_RANDOM_START 1 
.................... #define EEPROM_RUNNING_PROGRAM 5 
....................  
....................  
....................  
.................... /********************************************************** 
.................... / Application Global 
.................... /**********************************************************/ 
.................... int8 program_running = 0; 
*
1015:  CLRF   2F
....................  
.................... /********************************************************** 
.................... / Randomize 
.................... /**********************************************************/ 
.................... void random_update(int delta) 
.................... { 
.................... 	int random_start; 
....................     random_start = read_eeprom(EEPROM_RANDOM_START); 
*
02E5:  MOVLW  01
02E6:  BCF    03.5
02E7:  MOVWF  0D
02E8:  BSF    03.5
02E9:  BCF    0C.7
02EA:  BSF    0C.0
02EB:  BCF    03.5
02EC:  MOVF   0C,W
02ED:  BSF    03.5
02EE:  MOVWF  1E
.................... 	random_start += delta; 
02EF:  MOVF   1D,W
02F0:  ADDWF  1E,F
.................... 	srand(random_start); 
02F1:  CLRF   22
02F2:  CLRF   21
02F3:  CLRF   20
02F4:  MOVF   1E,W
02F5:  MOVWF  1F
02F6:  BCF    03.5
02F7:  BCF    03.6
02F8:  CALL   201
.................... //	write_eeprom(EEPROM_RANDOM_START,random_start); 
.................... } 
....................  
.................... void random_init() 
.................... { 
.................... 	int random_start; 
....................     random_start = read_eeprom(EEPROM_RANDOM_START); 
*
021A:  MOVLW  01
021B:  BSF    03.6
021C:  MOVWF  0D
021D:  BSF    03.5
021E:  BCF    0C.7
021F:  BSF    0C.0
0220:  BCF    03.5
0221:  MOVF   0C,W
0222:  BSF    03.5
0223:  MOVWF  1A
.................... 	srand(random_start); 
0224:  CLRF   22
0225:  CLRF   21
0226:  CLRF   20
0227:  MOVF   1A,W
0228:  MOVWF  1F
0229:  BCF    03.5
022A:  BCF    03.6
022B:  CALL   201
.................... } 
022C:  BCF    0A.3
022D:  BSF    0A.4
022E:  GOTO   2A6 (RETURN)
....................  
.................... /********************************************************** 
.................... / Common Timer 
.................... /**********************************************************/ 
.................... #define TIMER1_50MSEC_OFF_10MHZ 30000 
.................... #define TIMER1_50MSEC_10MHZ 34285 
.................... #define TIMER1_100MSEC_10MHZ 3035 
.................... #define TIMER1_10MSEC_20MHZ 15536 
.................... #define TIMER1_1MSEC_20MHZ 60536 
.................... #define TIMER1_3MSEC_20MHZ 50536 
.................... #define TIMER1_5MSEC_20MHZ 40536 
....................  
.................... int1 timeout1msec = 0; 
*
1016:  BCF    30.0
.................... int1 timeout10msec = 0; 
1017:  BCF    30.1
.................... int1 timeout100msec = 0; 
1018:  BCF    30.2
.................... int  countdown10 = 10; 
1019:  MOVLW  0A
101A:  MOVWF  31
.................... int  countdown100 = 10; 
101B:  MOVWF  32
....................  
.................... #INT_TIMER1 
.................... void timeproc() 
.................... { 
....................    set_timer1(get_timer1() + TIMER1_1MSEC_20MHZ); 
*
00DA:  MOVF   0F,W
00DB:  MOVWF  7A
00DC:  MOVF   0E,W
00DD:  MOVWF  77
00DE:  MOVF   0F,W
00DF:  SUBWF  7A,W
00E0:  BTFSS  03.2
00E1:  GOTO   0DA
00E2:  MOVF   77,W
00E3:  BSF    03.5
00E4:  BSF    03.6
00E5:  MOVWF  3A
00E6:  MOVF   7A,W
00E7:  MOVWF  3B
00E8:  MOVLW  78
00E9:  ADDWF  3A,W
00EA:  MOVWF  3C
00EB:  MOVF   3B,W
00EC:  MOVWF  3D
00ED:  MOVLW  EC
00EE:  BTFSC  03.0
00EF:  MOVLW  ED
00F0:  ADDWF  3D,F
00F1:  MOVF   3D,W
00F2:  BCF    03.5
00F3:  BCF    03.6
00F4:  MOVWF  0F
00F5:  BSF    03.5
00F6:  BSF    03.6
00F7:  MOVF   3C,W
00F8:  BCF    03.5
00F9:  BCF    03.6
00FA:  MOVWF  0E
....................    timeout1msec = 1; 
00FB:  BSF    30.0
....................    if (countdown10 == 0) { 
00FC:  MOVF   31,F
00FD:  BTFSS  03.2
00FE:  GOTO   10B
....................     timeout10msec = 1; 
00FF:  BSF    30.1
....................     countdown10 = 10; 
0100:  MOVLW  0A
0101:  MOVWF  31
....................    	if (countdown100 == 0) { 
0102:  MOVF   32,F
0103:  BTFSS  03.2
0104:  GOTO   109
....................     	timeout100msec = 1; 
0105:  BSF    30.2
....................     	countdown100 = 10; 
0106:  MOVLW  0A
0107:  MOVWF  32
....................    	} else countdown100--; 
0108:  GOTO   10A
0109:  DECF   32,F
....................    } else countdown10--; 
010A:  GOTO   10C
010B:  DECF   31,F
.................... } 
....................  
.................... //********************************************************** 
.................... // QUEUE HANDLING 
.................... //********************************************************** 
.................... #define QUEUE_LENGTH 10 
010C:  BCF    0C.0
010D:  BCF    0A.3
010E:  BCF    0A.4
010F:  GOTO   029
.................... char queue[QUEUE_LENGTH]; 
.................... int8 queue_start = 0; 
*
101C:  CLRF   3D
.................... int8 queue_stop = 0; 
101D:  CLRF   3E
....................  
.................... int8 get_queue_length() 
.................... { 
....................   if (queue_start == queue_stop) return 0; 
....................   if (queue_start < queue_stop) return  (queue_stop - queue_start); 
....................   else return  (QUEUE_LENGTH-queue_start) + queue_stop; 
.................... } 
....................  
.................... void push(char c) 
.................... { 
.................... // fprintf(terminal,"push %c qlen: %u qstart: %u qstop: %u \r\n",c,get_queue_length(),queue_start,queue_stop); 
....................  queue[queue_stop] = c; 
*
0B23:  MOVLW  33
0B24:  ADDWF  3E,W
0B25:  MOVWF  04
0B26:  BCF    03.7
0B27:  BSF    03.5
0B28:  BSF    03.6
0B29:  MOVF   23,W
0B2A:  MOVWF  00
....................  if (queue_stop == (QUEUE_LENGTH-1)) { 
0B2B:  BCF    03.5
0B2C:  BCF    03.6
0B2D:  MOVF   3E,W
0B2E:  SUBLW  09
0B2F:  BTFSS  03.2
0B30:  GOTO   336
....................    if (queue_start>0) { 
0B31:  MOVF   3D,F
0B32:  BTFSC  03.2
0B33:  GOTO   335
....................     queue_stop = 0; 
0B34:  CLRF   3E
....................    } 
....................  } else { 
0B35:  GOTO   33C
....................   if (queue_stop == (queue_start - 1)) { 
0B36:  MOVLW  01
0B37:  SUBWF  3D,W
0B38:  SUBWF  3E,W
0B39:  BTFSC  03.2
....................   } else { 
0B3A:  GOTO   33C
....................    queue_stop++; 
0B3B:  INCF   3E,F
....................   } 
....................  }  
....................  // output_high(INT_PIN); 
.................... } 
0B3C:  RETLW  00
....................  
.................... char pop() 
.................... { 
....................  char c = 0; 
*
07D3:  BSF    03.5
07D4:  BSF    03.6
07D5:  CLRF   1A
....................  if (queue_start != queue_stop) { 
07D6:  BCF    03.5
07D7:  BCF    03.6
07D8:  MOVF   3E,W
07D9:  SUBWF  3D,W
07DA:  BTFSC  03.2
07DB:  GOTO   7ED
....................   c = queue[queue_start]; 
07DC:  MOVLW  33
07DD:  ADDWF  3D,W
07DE:  MOVWF  04
07DF:  BCF    03.7
07E0:  MOVF   00,W
07E1:  BSF    03.5
07E2:  BSF    03.6
07E3:  MOVWF  1A
.................... //  fprintf(terminal,"pop %c qstart: %u qstop: %u \r\n",c,queue_start,queue_stop); 
....................   if (queue_start == (QUEUE_LENGTH-1)) queue_start = 0; 
07E4:  BCF    03.5
07E5:  BCF    03.6
07E6:  MOVF   3D,W
07E7:  SUBLW  09
07E8:  BTFSS  03.2
07E9:  GOTO   7EC
07EA:  CLRF   3D
....................   else { 
07EB:  GOTO   7ED
....................     queue_start++; 
07EC:  INCF   3D,F
....................   } 
....................  } 
....................  return c; 
07ED:  BSF    03.5
07EE:  BSF    03.6
07EF:  MOVF   1A,W
07F0:  MOVWF  78
.................... } 
07F1:  BCF    03.6
07F2:  BCF    03.5
07F3:  BCF    0A.3
07F4:  BSF    0A.4
07F5:  GOTO   2F7 (RETURN)
....................  
.................... /********************************************************** 
.................... / LEDs 
.................... /**********************************************************/ 
.................... #byte PORTA = 0x5 
....................  
.................... void button_led_on(int ledid) 
.................... { 
.................... 	PORTA |= (1 << ledid); 
*
0270:  MOVLW  01
0271:  MOVWF  77
0272:  BSF    03.5
0273:  BSF    03.6
0274:  MOVF   20,W
0275:  MOVWF  78
0276:  BTFSC  03.2
0277:  GOTO   27C
0278:  BCF    03.0
0279:  RLF    77,F
027A:  DECFSZ 78,F
027B:  GOTO   278
027C:  MOVF   77,W
027D:  BCF    03.5
027E:  BCF    03.6
027F:  IORWF  05,F
.................... } 
0280:  RETLW  00
....................  
.................... void button_led_off(int ledid) 
.................... { 
.................... 	PORTA &= ~(1 << ledid); 
*
0C6D:  MOVLW  01
0C6E:  MOVWF  77
0C6F:  MOVF   1A,W
0C70:  MOVWF  78
0C71:  BTFSC  03.2
0C72:  GOTO   477
0C73:  BCF    03.0
0C74:  RLF    77,F
0C75:  DECFSZ 78,F
0C76:  GOTO   473
0C77:  MOVF   77,W
0C78:  XORLW  FF
0C79:  BCF    03.5
0C7A:  BCF    03.6
0C7B:  ANDWF  05,F
.................... } 
....................  
.................... void button_led_clearall() 
.................... { 
.................... 	PORTA = 0; 
*
0157:  CLRF   05
.................... } 
0158:  RETLW  00
....................  
.................... void set_kbd_lamp(int8 no) 
.................... { 
....................     // PORTB 
....................     // rrrrcccx 
.................... 	int8 row; 
....................     int8 col; 
....................     no--; 
*
0172:  BSF    03.5
0173:  BSF    03.6
0174:  DECF   1D,F
....................     row = no / 3; 
0175:  MOVF   1D,W
0176:  MOVWF  36
0177:  MOVLW  03
0178:  MOVWF  37
0179:  BCF    03.5
017A:  BCF    03.6
017B:  CALL   159
017C:  MOVF   78,W
017D:  BSF    03.5
017E:  BSF    03.6
017F:  MOVWF  1E
....................     col = no - (row * 3); 
0180:  MOVF   1E,W
0181:  MOVWF  20
0182:  MOVLW  03
0183:  MOVWF  21
*
01A8:  MOVF   78,W
01A9:  SUBWF  1D,W
01AA:  MOVWF  1F
.................... 	output_b(   
.................... 			  ( (1 << (row))  << 4)  
.................... 			| (  1 << (col+1))  
.................... 			); 
01AB:  MOVLW  01
01AC:  MOVWF  77
01AD:  MOVF   1E,W
01AE:  MOVWF  78
01AF:  BTFSC  03.2
01B0:  GOTO   1B5
01B1:  BCF    03.0
01B2:  RLF    77,F
01B3:  DECFSZ 78,F
01B4:  GOTO   1B1
01B5:  MOVF   77,W
01B6:  SWAPF  77,W
01B7:  MOVWF  21
01B8:  MOVLW  F0
01B9:  ANDWF  21,F
01BA:  MOVLW  01
01BB:  ADDWF  1F,W
01BC:  MOVWF  78
01BD:  MOVLW  01
01BE:  MOVWF  77
01BF:  MOVF   78,F
01C0:  BTFSC  03.2
01C1:  GOTO   1C6
01C2:  BCF    03.0
01C3:  RLF    77,F
01C4:  DECFSZ 78,F
01C5:  GOTO   1C2
01C6:  MOVF   77,W
01C7:  IORWF  21,W
01C8:  MOVWF  22
01C9:  BCF    03.5
01CA:  BCF    03.6
01CB:  MOVWF  06
.................... } 
01CC:  RETLW  00
....................  
.................... //********************************************************** 
.................... // 4x4 MATRIX KEYBOARD HANDLING 
.................... //********************************************************** 
.................... #define MBIT_MAKE          0b00010000 
.................... #define MBIT_BREAK         0b00100000 
....................  
.................... #define MBIT_LEFT          0b00000100 
.................... #define MBIT_RIGHT         0b00001000 
....................  
.................... #define MBIT_CODE_MASK     0b00001111 
....................  
.................... #define MBIT_ID_MASK       0b11000000 
.................... #define MBIT_ID_KEYBOARD   0b00000000 
.................... #define MBIT_ID_BUTTON     0b01000000 
.................... #define MBIT_ID_BUTTONPUSH 0b10000000 
.................... #define MBIT_ID_LED 	   0b11000000 
....................  
.................... #byte KBPORT = 0x8 
....................  
.................... #define KCOL0 (1 << 1) 
.................... #define KCOL1 (1 << 2) 
.................... #define KCOL2 (1 << 3) 
....................  
.................... #define KROW0 (1 << 4) 
.................... #define KROW1 (1 << 5) 
.................... #define KROW2 (1 << 6) 
.................... #define KROW3 (1 << 7) 
....................  
.................... #define KALL_ROWS (KROW0|KROW1|KROW2|KROW3) 
.................... #define KALL_PINS (KALL_ROWS|KCOL0|KCOL1|KCOL2) 
....................  
.................... #define kset_tris(x) set_tris_d(x) 
....................  
.................... char const keycodes[16] = {1,4,7,10,2,5,8,11,3,6,9,12}; 
....................  
.................... void dokeyboard() 
.................... { 
....................  
.................... 	static int16 allkeys1 = 0xFFFF; 
*
101E:  MOVLW  FF
101F:  MOVWF  3F
1020:  MOVWF  40
.................... 	int16 allkeys = 0; 
*
0B91:  BSF    03.5
0B92:  BSF    03.6
0B93:  CLRF   1A
0B94:  CLRF   1B
....................     int16 deltakeys = 0; 
0B95:  CLRF   1C
0B96:  CLRF   1D
....................     int16 i; 
....................     int16 test = 0; 
0B97:  CLRF   20
0B98:  CLRF   21
.................... 	 
.................... 	kset_tris(KALL_PINS&~KCOL0); 
0B99:  MOVLW  FC
0B9A:  BCF    03.6
0B9B:  MOVWF  08
....................     KBPORT=~KCOL0&KALL_PINS; 
0B9C:  BCF    03.5
0B9D:  MOVWF  08
....................     delay_cycles(10); 
0B9E:  MOVLW  03
0B9F:  MOVWF  77
0BA0:  DECFSZ 77,F
0BA1:  GOTO   3A0
....................     allkeys = (int16)((KBPORT & KALL_ROWS) >> 4); 
0BA2:  MOVF   08,W
0BA3:  ANDLW  F0
0BA4:  MOVWF  77
0BA5:  SWAPF  77,F
0BA6:  MOVLW  0F
0BA7:  ANDWF  77,F
0BA8:  MOVF   77,W
0BA9:  BSF    03.5
0BAA:  BSF    03.6
0BAB:  CLRF   1B
0BAC:  MOVWF  1A
....................  
.................... 	kset_tris(KALL_PINS&~KCOL1); 
0BAD:  MOVLW  FA
0BAE:  BCF    03.6
0BAF:  MOVWF  08
....................     KBPORT=~KCOL1&KALL_PINS; 
0BB0:  BCF    03.5
0BB1:  MOVWF  08
....................     delay_cycles(10); 
0BB2:  MOVLW  03
0BB3:  MOVWF  77
0BB4:  DECFSZ 77,F
0BB5:  GOTO   3B4
....................     allkeys |= (int16)((KBPORT & KALL_ROWS) ); 
0BB6:  MOVF   08,W
0BB7:  ANDLW  F0
0BB8:  CLRF   7A
0BB9:  BSF    03.5
0BBA:  BSF    03.6
0BBB:  IORWF  1A,F
0BBC:  MOVF   7A,W
0BBD:  IORWF  1B,F
....................  
.................... 	kset_tris(KALL_PINS&~KCOL2); 
0BBE:  MOVLW  F6
0BBF:  BCF    03.6
0BC0:  MOVWF  08
....................     KBPORT=~KCOL2&KALL_PINS; 
0BC1:  BCF    03.5
0BC2:  MOVWF  08
....................     delay_cycles(10); 
0BC3:  MOVLW  03
0BC4:  MOVWF  77
0BC5:  DECFSZ 77,F
0BC6:  GOTO   3C5
....................     test = ((KBPORT & KALL_ROWS) >> 4); 
0BC7:  MOVF   08,W
0BC8:  ANDLW  F0
0BC9:  MOVWF  79
0BCA:  BSF    03.5
0BCB:  BSF    03.6
0BCC:  CLRF   21
0BCD:  RRF    79,W
0BCE:  MOVWF  20
0BCF:  RRF    20,F
0BD0:  RRF    20,F
0BD1:  RRF    20,F
0BD2:  MOVLW  0F
0BD3:  ANDWF  20,F
.................... //    if (test != 0b00001111) button_led_on(4); 
....................     allkeys |= (int16)(test << 8); 
0BD4:  MOVLW  00
0BD5:  IORWF  1A,F
0BD6:  MOVF   20,W
0BD7:  IORWF  1B,F
....................    
....................     if (allkeys != allkeys1) { 
0BD8:  BCF    03.5
0BD9:  BCF    03.6
0BDA:  MOVF   3F,W
0BDB:  BSF    03.5
0BDC:  BSF    03.6
0BDD:  SUBWF  1A,W
0BDE:  BTFSS  03.2
0BDF:  GOTO   3E8
0BE0:  BCF    03.5
0BE1:  BCF    03.6
0BE2:  MOVF   40,W
0BE3:  BSF    03.5
0BE4:  BSF    03.6
0BE5:  SUBWF  1B,W
0BE6:  BTFSC  03.2
0BE7:  GOTO   462
....................      deltakeys = (allkeys ^ allkeys1); 
0BE8:  MOVF   1A,W
0BE9:  BCF    03.5
0BEA:  BCF    03.6
0BEB:  XORWF  3F,W
0BEC:  BSF    03.5
0BED:  BSF    03.6
0BEE:  MOVWF  1C
0BEF:  MOVF   1B,W
0BF0:  BCF    03.5
0BF1:  BCF    03.6
0BF2:  XORWF  40,W
0BF3:  BSF    03.5
0BF4:  BSF    03.6
0BF5:  MOVWF  1D
....................      for (i=0;i<12;i++) { 
0BF6:  CLRF   1F
0BF7:  CLRF   1E
0BF8:  MOVF   1F,F
0BF9:  BTFSS  03.2
0BFA:  GOTO   456
0BFB:  MOVF   1E,W
0BFC:  SUBLW  0B
0BFD:  BTFSS  03.0
0BFE:  GOTO   456
....................       if (deltakeys & ( 1 << i)) { 
0BFF:  CLRF   7A
0C00:  MOVLW  01
0C01:  MOVWF  79
0C02:  MOVF   1E,W
0C03:  MOVWF  77
0C04:  BTFSC  03.2
0C05:  GOTO   40B
0C06:  BCF    03.0
0C07:  RLF    79,F
0C08:  RLF    7A,F
0C09:  DECFSZ 77,F
0C0A:  GOTO   406
0C0B:  MOVF   79,W
0C0C:  ANDWF  1C,W
0C0D:  MOVWF  77
0C0E:  MOVF   7A,W
0C0F:  ANDWF  1D,W
0C10:  MOVWF  7A
0C11:  MOVF   77,W
0C12:  IORWF  7A,W
0C13:  BTFSC  03.2
0C14:  GOTO   452
....................         if (allkeys & ( 1 << i)) push(MBIT_ID_KEYBOARD | MBIT_BREAK | keycodes[i]); 
0C15:  CLRF   7A
0C16:  MOVLW  01
0C17:  MOVWF  79
0C18:  MOVF   1E,W
0C19:  MOVWF  77
0C1A:  BTFSC  03.2
0C1B:  GOTO   421
0C1C:  BCF    03.0
0C1D:  RLF    79,F
0C1E:  RLF    7A,F
0C1F:  DECFSZ 77,F
0C20:  GOTO   41C
0C21:  MOVF   79,W
0C22:  ANDWF  1A,W
0C23:  MOVWF  77
0C24:  MOVF   7A,W
0C25:  ANDWF  1B,W
0C26:  MOVWF  7A
0C27:  MOVF   77,W
0C28:  IORWF  7A,W
0C29:  BTFSC  03.2
0C2A:  GOTO   43F
0C2B:  MOVF   1F,W
0C2C:  MOVWF  7A
0C2D:  MOVF   1E,W
0C2E:  BCF    0A.3
0C2F:  BCF    03.5
0C30:  BCF    03.6
0C31:  CALL   045
0C32:  BSF    0A.3
0C33:  MOVWF  78
0C34:  IORLW  20
0C35:  BSF    03.5
0C36:  BSF    03.6
0C37:  MOVWF  22
0C38:  MOVWF  23
0C39:  BCF    03.5
0C3A:  BCF    03.6
0C3B:  CALL   323
....................         else push(MBIT_ID_KEYBOARD | MBIT_MAKE | keycodes[i]); 
0C3C:  GOTO   450
0C3D:  BSF    03.5
0C3E:  BSF    03.6
0C3F:  MOVF   1F,W
0C40:  MOVWF  7A
0C41:  MOVF   1E,W
0C42:  BCF    0A.3
0C43:  BCF    03.5
0C44:  BCF    03.6
0C45:  CALL   045
0C46:  BSF    0A.3
0C47:  MOVWF  78
0C48:  IORLW  10
0C49:  BSF    03.5
0C4A:  BSF    03.6
0C4B:  MOVWF  22
0C4C:  MOVWF  23
0C4D:  BCF    03.5
0C4E:  BCF    03.6
0C4F:  CALL   323
0C50:  BSF    03.5
0C51:  BSF    03.6
....................       } 
....................      } 
0C52:  INCF   1E,F
0C53:  BTFSC  03.2
0C54:  INCF   1F,F
0C55:  GOTO   3F8
....................  
....................     // fprintf(DEBUGGER,"kstat: %X %X\r\n",*(&allkeys+1),allkeys); 
....................  
....................      allkeys1 = allkeys; 
0C56:  MOVF   1B,W
0C57:  BCF    03.5
0C58:  BCF    03.6
0C59:  MOVWF  40
0C5A:  BSF    03.5
0C5B:  BSF    03.6
0C5C:  MOVF   1A,W
0C5D:  BCF    03.5
0C5E:  BCF    03.6
0C5F:  MOVWF  3F
0C60:  BSF    03.5
0C61:  BSF    03.6
....................     } 
.................... } 
0C62:  BCF    03.6
0C63:  BCF    03.5
0C64:  BCF    0A.3
0C65:  BSF    0A.4
0C66:  GOTO   305 (RETURN)
....................  
.................... //********************************************************** 
.................... // 1x5 STATIC KEYBOARD HANDLING (BIG BUTTONS) 
.................... //********************************************************** 
.................... void dobuttonpush() 
.................... { 
....................   static int8 keystate1 = 0xFF; 
*
1021:  MOVWF  41
....................   int8 keystate; 
....................   int8 keydelta; 
....................   int8 i; 
....................  
....................   keystate = input_c(); 
*
0B3D:  MOVF   07,W
0B3E:  BSF    03.5
0B3F:  BSF    03.6
0B40:  MOVWF  1A
....................   if (keystate != keystate1)  
0B41:  BCF    03.5
0B42:  BCF    03.6
0B43:  MOVF   41,W
0B44:  BSF    03.5
0B45:  BSF    03.6
0B46:  SUBWF  1A,W
0B47:  BTFSC  03.2
0B48:  GOTO   38C
....................   { 
....................     keydelta = (keystate ^ keystate1); 
0B49:  MOVF   1A,W
0B4A:  BCF    03.5
0B4B:  BCF    03.6
0B4C:  XORWF  41,W
0B4D:  BSF    03.5
0B4E:  BSF    03.6
0B4F:  MOVWF  1B
....................     for (i=0;i<6;i++) { 
0B50:  CLRF   1C
0B51:  MOVF   1C,W
0B52:  SUBLW  05
0B53:  BTFSS  03.0
0B54:  GOTO   386
....................      if (keydelta & ( 1 << i)) { 
0B55:  MOVLW  01
0B56:  MOVWF  77
0B57:  MOVF   1C,W
0B58:  MOVWF  78
0B59:  BTFSC  03.2
0B5A:  GOTO   35F
0B5B:  BCF    03.0
0B5C:  RLF    77,F
0B5D:  DECFSZ 78,F
0B5E:  GOTO   35B
0B5F:  MOVF   77,W
0B60:  ANDWF  1B,W
0B61:  BTFSC  03.2
0B62:  GOTO   384
....................        if (keystate & (1 << i)) push (MBIT_ID_BUTTONPUSH | MBIT_BREAK | i ); 
0B63:  MOVLW  01
0B64:  MOVWF  77
0B65:  MOVF   1C,W
0B66:  MOVWF  78
0B67:  BTFSC  03.2
0B68:  GOTO   36D
0B69:  BCF    03.0
0B6A:  RLF    77,F
0B6B:  DECFSZ 78,F
0B6C:  GOTO   369
0B6D:  MOVF   77,W
0B6E:  ANDWF  1A,W
0B6F:  BTFSC  03.2
0B70:  GOTO   37B
0B71:  MOVF   1C,W
0B72:  IORLW  A0
0B73:  MOVWF  1D
0B74:  MOVWF  23
0B75:  BCF    03.5
0B76:  BCF    03.6
0B77:  CALL   323
....................        else push (MBIT_ID_BUTTONPUSH | MBIT_MAKE | i ); 
0B78:  GOTO   382
0B79:  BSF    03.5
0B7A:  BSF    03.6
0B7B:  MOVF   1C,W
0B7C:  IORLW  90
0B7D:  MOVWF  1D
0B7E:  MOVWF  23
0B7F:  BCF    03.5
0B80:  BCF    03.6
0B81:  CALL   323
0B82:  BSF    03.5
0B83:  BSF    03.6
....................      } 
....................     }     
0B84:  INCF   1C,F
0B85:  GOTO   351
....................     keystate1 = keystate; 
0B86:  MOVF   1A,W
0B87:  BCF    03.5
0B88:  BCF    03.6
0B89:  MOVWF  41
0B8A:  BSF    03.5
0B8B:  BSF    03.6
....................   } 
....................    
.................... } 
0B8C:  BCF    03.6
0B8D:  BCF    03.5
0B8E:  BCF    0A.3
0B8F:  BSF    0A.4
0B90:  GOTO   2FE (RETURN)
....................  
....................  
.................... /********************************************************** 
.................... / Serial Input Buffer 
.................... /**********************************************************/ 
.................... #define MP3_REPORT_BUFFER_LENGTH 32 
.................... #define MP3_COLUMN_LENGTH 20 
.................... BYTE mp3buffer[MP3_REPORT_BUFFER_LENGTH]; 
.................... int8 mp3bufferptr = 0; 
*
1022:  CLRF   62
.................... int8 mp3status = 0; 
1023:  CLRF   63
.................... int8 mp3completed = 0; 
1024:  CLRF   64
.................... int1 mp3received = 0; 
1025:  BCF    30.3
....................  
....................     
.................... #INT_RDA 
.................... void serial_isr() { 
....................    BYTE c; 
....................    c = fgetc(mp3player); 
*
011A:  MOVF   78,W
011B:  BSF    03.5
011C:  BSF    03.6
011D:  MOVWF  3A
....................    if (!mp3received) { 
011E:  BCF    03.5
011F:  BCF    03.6
0120:  BTFSC  30.3
0121:  GOTO   144
....................     if (c == '>')  { 
0122:  BSF    03.5
0123:  BSF    03.6
0124:  MOVF   3A,W
0125:  SUBLW  3E
0126:  BTFSS  03.2
0127:  GOTO   134
....................      mp3buffer[mp3bufferptr] = 0; 
0128:  MOVLW  42
0129:  BCF    03.5
012A:  BCF    03.6
012B:  ADDWF  62,W
012C:  MOVWF  04
012D:  BCF    03.7
012E:  CLRF   00
....................      mp3received = 1; 
012F:  BSF    30.3
....................      mp3bufferptr = 0; 
0130:  CLRF   62
....................     } else { 
0131:  GOTO   144
0132:  BSF    03.5
0133:  BSF    03.6
....................      mp3buffer[mp3bufferptr] = c; 
0134:  MOVLW  42
0135:  BCF    03.5
0136:  BCF    03.6
0137:  ADDWF  62,W
0138:  MOVWF  04
0139:  BCF    03.7
013A:  BSF    03.5
013B:  BSF    03.6
013C:  MOVF   3A,W
013D:  MOVWF  00
....................      if (mp3bufferptr < MP3_REPORT_BUFFER_LENGTH) mp3bufferptr++; 
013E:  BCF    03.5
013F:  BCF    03.6
0140:  MOVF   62,W
0141:  SUBLW  1F
0142:  BTFSC  03.0
0143:  INCF   62,F
....................     } 
....................    } 
.................... } 
.................... /********************************************************** 
.................... / MP3 Control 
.................... /**********************************************************/ 
....................  
0144:  BCF    0C.5
0145:  BCF    0A.3
0146:  BCF    0A.4
0147:  GOTO   029
.................... int8 cfg_mp3volume = 60; 
*
1026:  MOVLW  3C
1027:  MOVWF  65
....................  
.................... int1 mp3playing = 0; 
1028:  BCF    30.4
.................... int8 mp3timeout = 0; 
1029:  CLRF   66
.................... int8 mp3retries = 0; 
102A:  CLRF   67
....................  
.................... char mp3title[10]; 
....................  
.................... #define MP3_STATUS_READY 0 
.................... #define MP3_CMD_QUERY_STATUS 1 
.................... #define MP3_CMD_SET_VOLUME 2 
.................... #define MP3_CMD_PLAY 3 
.................... #define MP3_CMD_STOP 4 
.................... #define MP3_STATUS_INIT_0 5 
.................... #define MP3_STATUS_INIT_1 6 
.................... #define MP3_STATUS_INIT_2 7 
.................... #define MP3_STATUS_INIT_3 8 
.................... #define MP3_CMD_OPEN_TITLEFILE 9 
.................... #define MP3_CMD_QUERY_TITLE 10 
.................... #define MP3_CMD_QUERY_ARTIST 11 
.................... #define MP3_CMD_OPEN_COUNTERFILE 12 
.................... #define MP3_CMD_QUERY_COUNTERS 13 
.................... #define MP3_CMD_CLOSE_TITLEFILE 14 
.................... #define MP3_CMD_CLOSE_COUNTERFILE 15 
.................... #define MP3_CMD_QUERY_LENGTH 16 
.................... #define MP3_CMD_SET_BASS_ENHANCE 17 
.................... #define MP3_CMD_SET_SERIAL_SPEED 18 
.................... #define MP3_CMD_LOAD_MACRO 19 
.................... #define MP3_CMD_ENABLE_BUSY_IND 20 
.................... #define MP3_CMD_LOOP_ON 21 
.................... #define MP3_CMD_LOOP_OFF 22 
....................  
.................... #define MP3_DEFAULT_TIMEOUT 100 
....................  
.................... #define MP3_VOLUME_MINIMUM 120 
.................... #define MP3_VOLUME_MAXIMUM 50 
.................... #define MP3_VOLUME_DEFAULT 90 
.................... /* 
.................... int8 mp3initsequencecount = 8; 
.................... int8 mp3initsequence[8] =[MP3_CMD_SET_SERIAL_SPEED, 
....................                       MP3_CMD_SET_BASS_ENHANCE, 
....................                       MP3_CMD_SET_VOLUME, 
....................                       MP3_CMD_CLOSE_TITLEFILE, 
....................                       MP3_CMD_CLOSE_COUNTERFILE, 
....................                       MP3_CMD_OPEN_TITLEFILE, 
....................                       MP3_CMD_OPEN_COUNTERFILE, 
....................                       MP3_CMD_QUERY_COUNTERS]; 
.................... */ 
....................  
....................  
.................... void mp3sendcommand() 
.................... { 
....................  // button_led_off(5); 
....................   if      (mp3status ==  MP3_CMD_QUERY_STATUS) fprintf(mp3player,"PC Z\r"); 
*
0443:  DECFSZ 63,W
0444:  GOTO   45E
0445:  BSF    03.5
0446:  BSF    03.6
0447:  CLRF   1A
0448:  MOVF   1A,W
0449:  BCF    03.5
044A:  BCF    03.6
044B:  CALL   059
044C:  BSF    03.5
044D:  BSF    03.6
044E:  INCF   1A,F
044F:  MOVWF  77
0450:  BCF    03.5
0451:  BCF    03.6
0452:  BTFSS  0C.4
0453:  GOTO   452
0454:  MOVWF  19
0455:  MOVLW  05
0456:  BSF    03.5
0457:  BSF    03.6
0458:  SUBWF  1A,W
0459:  BTFSS  03.2
045A:  GOTO   448
....................   else if (mp3status ==  MP3_CMD_PLAY) { 
045B:  GOTO   580
045C:  BCF    03.5
045D:  BCF    03.6
045E:  MOVF   63,W
045F:  SUBLW  03
0460:  BTFSS  03.2
0461:  GOTO   4A2
.................... 	mp3playing = 1; 
0462:  BSF    30.4
.................... 	fprintf(mp3player,"PC F /0/%s.mp3\r",mp3title); 
0463:  BSF    03.5
0464:  BSF    03.6
0465:  CLRF   1A
0466:  MOVF   1A,W
0467:  BCF    03.5
0468:  BCF    03.6
0469:  CALL   063
046A:  BSF    03.5
046B:  BSF    03.6
046C:  INCF   1A,F
046D:  MOVWF  77
046E:  BCF    03.5
046F:  BCF    03.6
0470:  BTFSS  0C.4
0471:  GOTO   470
0472:  MOVWF  19
0473:  MOVLW  08
0474:  BSF    03.5
0475:  BSF    03.6
0476:  SUBWF  1A,W
0477:  BTFSS  03.2
0478:  GOTO   466
0479:  MOVLW  68
047A:  MOVWF  04
047B:  BCF    03.7
047C:  MOVLW  00
047D:  IORWF  00,W
047E:  BTFSC  03.2
047F:  GOTO   48A
0480:  MOVF   00,W
0481:  BCF    03.5
0482:  BCF    03.6
0483:  BTFSS  0C.4
0484:  GOTO   483
0485:  MOVWF  19
0486:  INCF   04,F
0487:  BSF    03.5
0488:  BSF    03.6
0489:  GOTO   47C
048A:  MOVLW  0A
048B:  MOVWF  1D
048C:  MOVF   1D,W
048D:  BCF    03.5
048E:  BCF    03.6
048F:  CALL   063
0490:  BSF    03.5
0491:  BSF    03.6
0492:  INCF   1D,F
0493:  MOVWF  77
0494:  BCF    03.5
0495:  BCF    03.6
0496:  BTFSS  0C.4
0497:  GOTO   496
0498:  MOVWF  19
0499:  MOVLW  0F
049A:  BSF    03.5
049B:  BSF    03.6
049C:  SUBWF  1D,W
049D:  BTFSS  03.2
049E:  GOTO   48C
....................   } 
....................   else if (mp3status ==  MP3_CMD_STOP) fprintf(mp3player,"PC S\r"); 
049F:  GOTO   580
04A0:  BCF    03.5
04A1:  BCF    03.6
04A2:  MOVF   63,W
04A3:  SUBLW  04
04A4:  BTFSS  03.2
04A5:  GOTO   4BF
04A6:  BSF    03.5
04A7:  BSF    03.6
04A8:  CLRF   1A
04A9:  MOVF   1A,W
04AA:  BCF    03.5
04AB:  BCF    03.6
04AC:  CALL   077
04AD:  BSF    03.5
04AE:  BSF    03.6
04AF:  INCF   1A,F
04B0:  MOVWF  77
04B1:  BCF    03.5
04B2:  BCF    03.6
04B3:  BTFSS  0C.4
04B4:  GOTO   4B3
04B5:  MOVWF  19
04B6:  MOVLW  05
04B7:  BSF    03.5
04B8:  BSF    03.6
04B9:  SUBWF  1A,W
04BA:  BTFSS  03.2
04BB:  GOTO   4A9
....................   else if (mp3status ==  MP3_CMD_SET_VOLUME) fprintf(mp3player,"ST V %u\r",cfg_mp3volume); 
04BC:  GOTO   580
04BD:  BCF    03.5
04BE:  BCF    03.6
04BF:  MOVF   63,W
04C0:  SUBLW  02
04C1:  BTFSS  03.2
04C2:  GOTO   4E9
04C3:  BSF    03.5
04C4:  BSF    03.6
04C5:  CLRF   1A
04C6:  MOVF   1A,W
04C7:  BCF    03.5
04C8:  BCF    03.6
04C9:  CALL   081
04CA:  BSF    03.5
04CB:  BSF    03.6
04CC:  INCF   1A,F
04CD:  MOVWF  77
04CE:  BCF    03.5
04CF:  BCF    03.6
04D0:  BTFSS  0C.4
04D1:  GOTO   4D0
04D2:  MOVWF  19
04D3:  MOVLW  05
04D4:  BSF    03.5
04D5:  BSF    03.6
04D6:  SUBWF  1A,W
04D7:  BTFSS  03.2
04D8:  GOTO   4C6
04D9:  BCF    03.5
04DA:  BCF    03.6
04DB:  MOVF   65,W
04DC:  BSF    03.5
04DD:  BSF    03.6
04DE:  MOVWF  1B
04DF:  MOVLW  1B
04E0:  MOVWF  1C
04E1:  BCF    03.5
04E2:  BCF    03.6
04E3:  CALL   3F7
04E4:  MOVLW  0D
04E5:  BTFSS  0C.4
04E6:  GOTO   4E5
04E7:  MOVWF  19
....................   else if (mp3status ==  MP3_CMD_SET_BASS_ENHANCE) fprintf(mp3player,"ST B %u\r",7); 
04E8:  GOTO   582
04E9:  MOVF   63,W
04EA:  SUBLW  11
04EB:  BTFSS  03.2
04EC:  GOTO   50F
04ED:  BSF    03.5
04EE:  BSF    03.6
04EF:  CLRF   1A
04F0:  MOVF   1A,W
04F1:  BCF    03.5
04F2:  BCF    03.6
04F3:  CALL   08E
04F4:  BSF    03.5
04F5:  BSF    03.6
04F6:  INCF   1A,F
04F7:  MOVWF  77
04F8:  BCF    03.5
04F9:  BCF    03.6
04FA:  BTFSS  0C.4
04FB:  GOTO   4FA
04FC:  MOVWF  19
04FD:  MOVLW  05
04FE:  BSF    03.5
04FF:  BSF    03.6
0500:  SUBWF  1A,W
0501:  BTFSS  03.2
0502:  GOTO   4F0
0503:  MOVLW  07
0504:  MOVWF  1B
0505:  MOVLW  1B
0506:  MOVWF  1C
0507:  BCF    03.5
0508:  BCF    03.6
0509:  CALL   3F7
050A:  MOVLW  0D
050B:  BTFSS  0C.4
050C:  GOTO   50B
050D:  MOVWF  19
....................   else if (mp3status ==  MP3_CMD_SET_SERIAL_SPEED) fprintf(mp3player,"ST D 2\r"); 
050E:  GOTO   582
050F:  MOVF   63,W
0510:  SUBLW  12
0511:  BTFSS  03.2
0512:  GOTO   52C
0513:  BSF    03.5
0514:  BSF    03.6
0515:  CLRF   1A
0516:  MOVF   1A,W
0517:  BCF    03.5
0518:  BCF    03.6
0519:  CALL   09B
051A:  BSF    03.5
051B:  BSF    03.6
051C:  INCF   1A,F
051D:  MOVWF  77
051E:  BCF    03.5
051F:  BCF    03.6
0520:  BTFSS  0C.4
0521:  GOTO   520
0522:  MOVWF  19
0523:  MOVLW  07
0524:  BSF    03.5
0525:  BSF    03.6
0526:  SUBWF  1A,W
0527:  BTFSS  03.2
0528:  GOTO   516
....................   else if (mp3status ==  MP3_CMD_ENABLE_BUSY_IND) fprintf(mp3player,"ST H 1\r"); 
0529:  GOTO   580
052A:  BCF    03.5
052B:  BCF    03.6
052C:  MOVF   63,W
052D:  SUBLW  14
052E:  BTFSS  03.2
052F:  GOTO   549
0530:  BSF    03.5
0531:  BSF    03.6
0532:  CLRF   1A
0533:  MOVF   1A,W
0534:  BCF    03.5
0535:  BCF    03.6
0536:  CALL   0A7
0537:  BSF    03.5
0538:  BSF    03.6
0539:  INCF   1A,F
053A:  MOVWF  77
053B:  BCF    03.5
053C:  BCF    03.6
053D:  BTFSS  0C.4
053E:  GOTO   53D
053F:  MOVWF  19
0540:  MOVLW  07
0541:  BSF    03.5
0542:  BSF    03.6
0543:  SUBWF  1A,W
0544:  BTFSS  03.2
0545:  GOTO   533
....................   else if (mp3status ==  MP3_CMD_LOOP_ON) fprintf(mp3player,"ST O 0\r"); 
0546:  GOTO   580
0547:  BCF    03.5
0548:  BCF    03.6
0549:  MOVF   63,W
054A:  SUBLW  15
054B:  BTFSS  03.2
054C:  GOTO   566
054D:  BSF    03.5
054E:  BSF    03.6
054F:  CLRF   1A
0550:  MOVF   1A,W
0551:  BCF    03.5
0552:  BCF    03.6
0553:  CALL   0B3
0554:  BSF    03.5
0555:  BSF    03.6
0556:  INCF   1A,F
0557:  MOVWF  77
0558:  BCF    03.5
0559:  BCF    03.6
055A:  BTFSS  0C.4
055B:  GOTO   55A
055C:  MOVWF  19
055D:  MOVLW  07
055E:  BSF    03.5
055F:  BSF    03.6
0560:  SUBWF  1A,W
0561:  BTFSS  03.2
0562:  GOTO   550
....................   else if (mp3status ==  MP3_CMD_LOOP_OFF) fprintf(mp3player,"ST O 1\r"); 
0563:  GOTO   580
0564:  BCF    03.5
0565:  BCF    03.6
0566:  MOVF   63,W
0567:  SUBLW  16
0568:  BTFSS  03.2
0569:  GOTO   582
056A:  BSF    03.5
056B:  BSF    03.6
056C:  CLRF   1A
056D:  MOVF   1A,W
056E:  BCF    03.5
056F:  BCF    03.6
0570:  CALL   0BF
0571:  BSF    03.5
0572:  BSF    03.6
0573:  INCF   1A,F
0574:  MOVWF  77
0575:  BCF    03.5
0576:  BCF    03.6
0577:  BTFSS  0C.4
0578:  GOTO   577
0579:  MOVWF  19
057A:  MOVLW  07
057B:  BSF    03.5
057C:  BSF    03.6
057D:  SUBWF  1A,W
057E:  BTFSS  03.2
057F:  GOTO   56D
0580:  BCF    03.5
0581:  BCF    03.6
....................   mp3timeout = MP3_DEFAULT_TIMEOUT; 
0582:  MOVLW  64
0583:  MOVWF  66
.................... } 
0584:  RETLW  00
....................  
....................  
.................... void mp3docommand(int8 commandid) 
.................... { 
....................  if (!mp3status) { 
....................   mp3status = commandid; 
....................   mp3retries = 5; 
....................   mp3sendcommand(); 
....................  } 
.................... } 
.................... #define MP3_QUEUE_LENGTH 30 
....................  
.................... int mp3command_queue[MP3_QUEUE_LENGTH]; 
.................... int mp3command_queue_start = 0; 
*
102B:  CLRF   72
.................... int mp3command_queue_stop = 0; 
102C:  CLRF   73
.................... int mp3command_last; 
....................  
.................... unsigned short int mp3get_queue_length() 
.................... { 
....................   if (mp3command_queue_start == mp3command_queue_stop) return 0; 
*
0585:  MOVF   73,W
0586:  SUBWF  72,W
0587:  BTFSS  03.2
0588:  GOTO   58C
0589:  MOVLW  00
058A:  MOVWF  78
058B:  GOTO   59A
....................   if (mp3command_queue_start < mp3command_queue_stop) return  (mp3command_queue_stop - mp3command_queue_start); 
058C:  MOVF   73,W
058D:  SUBWF  72,W
058E:  BTFSC  03.0
058F:  GOTO   595
0590:  MOVF   72,W
0591:  SUBWF  73,W
0592:  MOVWF  78
0593:  GOTO   59A
....................   else return  (MP3_QUEUE_LENGTH-mp3command_queue_start) + mp3command_queue_stop; 
0594:  GOTO   59A
0595:  MOVF   72,W
0596:  SUBLW  1E
0597:  ADDWF  73,W
0598:  MOVWF  78
0599:  GOTO   59A
.................... } 
....................  
.................... void mp3clearqueue() 
.................... { 
....................  mp3command_queue_start = 0; 
....................  mp3command_queue_stop = 0; 
....................  mp3retries = 1; 
....................  mp3timeout = 1; 
.................... } 
....................  
....................  
.................... void mp3commandpush(char c) 
.................... { 
.................... #ifdef DEBUG_MAIN 
....................  //debug_printf("push %c qlen: %u qstart: %u qstop: %u \r\n",c,get_queue_length(),mp3command_queue_start,mp3command_queue_stop); 
.................... #endif 
....................   
....................  if (c != mp3command_last) { 
*
01E1:  MOVF   74,W
01E2:  BSF    03.5
01E3:  BSF    03.6
01E4:  SUBWF  35,W
01E5:  BTFSC  03.2
01E6:  GOTO   1FE
....................  mp3command_queue[mp3command_queue_stop] = c; 
01E7:  MOVLW  A0
01E8:  ADDWF  73,W
01E9:  MOVWF  04
01EA:  BCF    03.7
01EB:  MOVF   35,W
01EC:  MOVWF  00
....................  if (mp3command_queue_stop == (MP3_QUEUE_LENGTH-1)) { 
01ED:  MOVF   73,W
01EE:  SUBLW  1D
01EF:  BTFSS  03.2
01F0:  GOTO   1F6
....................    if (mp3command_queue_start>0) { 
01F1:  MOVF   72,F
01F2:  BTFSC  03.2
01F3:  GOTO   1F5
....................     mp3command_queue_stop = 0; 
01F4:  CLRF   73
....................    } 
....................  } else { 
01F5:  GOTO   1FC
....................   if (mp3command_queue_stop == (mp3command_queue_start - 1)) { 
01F6:  MOVLW  01
01F7:  SUBWF  72,W
01F8:  SUBWF  73,W
01F9:  BTFSC  03.2
....................   } else { 
01FA:  GOTO   1FC
....................    mp3command_queue_stop++; 
01FB:  INCF   73,F
....................   } 
....................  }  
....................  mp3command_last = c; 
01FC:  MOVF   35,W
01FD:  MOVWF  74
....................  } 
....................   
.................... } 
01FE:  BCF    03.5
01FF:  BCF    03.6
0200:  RETLW  00
....................  
.................... char mp3commandpop() 
.................... { 
....................  char c = 0; 
*
05A2:  BSF    03.5
05A3:  BSF    03.6
05A4:  CLRF   1A
....................  if (mp3command_queue_start != mp3command_queue_stop) { 
05A5:  MOVF   73,W
05A6:  SUBWF  72,W
05A7:  BTFSC  03.2
05A8:  GOTO   5B6
....................   c = mp3command_queue[mp3command_queue_start]; 
05A9:  MOVLW  A0
05AA:  ADDWF  72,W
05AB:  MOVWF  04
05AC:  BCF    03.7
05AD:  MOVF   00,W
05AE:  MOVWF  1A
....................   if (mp3command_queue_start == (MP3_QUEUE_LENGTH-1)) mp3command_queue_start = 0; 
05AF:  MOVF   72,W
05B0:  SUBLW  1D
05B1:  BTFSS  03.2
05B2:  GOTO   5B5
05B3:  CLRF   72
....................   else { 
05B4:  GOTO   5B6
....................     mp3command_queue_start++; 
05B5:  INCF   72,F
....................   } 
....................  } 
....................  if (mp3command_queue_start == mp3command_queue_stop) mp3command_last = 0; 
05B6:  MOVF   73,W
05B7:  SUBWF  72,W
05B8:  BTFSC  03.2
05B9:  CLRF   74
....................  return c; 
05BA:  MOVF   1A,W
05BB:  MOVWF  78
.................... } 
....................  
.................... void mp3execute() 
.................... { 
....................  if (mp3get_queue_length() && (!mp3status)  && (!mp3received)) { 
*
059A:  MOVF   78,F
059B:  BTFSC  03.2
059C:  GOTO   5C3
059D:  MOVF   63,F
059E:  BTFSS  03.2
059F:  GOTO   5C3
05A0:  BTFSC  30.3
05A1:  GOTO   5C3
....................   mp3status = mp3commandpop(); 
*
05BC:  MOVF   78,W
05BD:  BCF    03.5
05BE:  BCF    03.6
05BF:  MOVWF  63
....................   mp3retries = 3; 
05C0:  MOVLW  03
05C1:  MOVWF  67
....................   mp3sendcommand(); 
05C2:  CALL   443
....................  } 
.................... } 
05C3:  BCF    0A.3
05C4:  BSF    0A.4
05C5:  GOTO   2C5 (RETURN)
....................  
.................... int1 mp3playtrack(char *name) 
.................... { 
....................   if (mp3playing) { 
*
0242:  BTFSS  30.4
0243:  GOTO   24B
....................   	mp3commandpush(MP3_CMD_STOP); 
0244:  MOVLW  04
0245:  BSF    03.5
0246:  BSF    03.6
0247:  MOVWF  35
0248:  BCF    03.5
0249:  BCF    03.6
024A:  CALL   1E1
....................   } 
....................   //if (!mp3playing) { 
....................   	strcpy(mp3title,name); 
024B:  BSF    03.5
024C:  BSF    03.6
024D:  MOVF   34,W
024E:  MOVWF  38
024F:  MOVF   33,W
0250:  MOVWF  37
0251:  CLRF   36
0252:  MOVLW  68
0253:  MOVWF  35
0254:  MOVF   37,W
0255:  MOVWF  04
0256:  BCF    03.7
0257:  BTFSC  38.0
0258:  BSF    03.7
0259:  MOVF   00,W
025A:  MOVWF  39
025B:  MOVF   35,W
025C:  MOVWF  04
025D:  BCF    03.7
025E:  BTFSC  36.0
025F:  BSF    03.7
0260:  MOVF   39,W
0261:  MOVWF  00
0262:  MOVF   00,F
0263:  BTFSC  03.2
0264:  GOTO   268
0265:  INCF   35,F
0266:  INCF   37,F
0267:  GOTO   254
....................   	mp3commandpush(MP3_CMD_PLAY); 
0268:  MOVLW  03
0269:  MOVWF  35
026A:  BCF    03.5
026B:  BCF    03.6
026C:  CALL   1E1
....................   	return 1; 
026D:  MOVLW  01
026E:  MOVWF  78
....................   //} 
....................  //return 0; 
.................... } 
026F:  RETLW  00
....................  
....................  
.................... /********************************************************** 
.................... / SAMPLES 
.................... /**********************************************************/ 
....................  
....................  
.................... /********************************************************** 
.................... / SUBPROGRAMS 
.................... /**********************************************************/ 
.................... char manc1track[] = "manc1"; 
*
102D:  MOVLW  6D
102E:  BSF    03.5
102F:  MOVWF  3E
1030:  MOVLW  61
1031:  MOVWF  3F
1032:  MOVLW  6E
1033:  MOVWF  40
1034:  MOVLW  63
1035:  MOVWF  41
1036:  MOVLW  31
1037:  MOVWF  42
1038:  CLRF   43
.................... char fart1track[] = "fart1"; 
1039:  MOVLW  66
103A:  MOVWF  44
103B:  MOVLW  61
103C:  MOVWF  45
103D:  MOVLW  72
103E:  MOVWF  46
103F:  MOVLW  74
1040:  MOVWF  47
1041:  MOVLW  31
1042:  MOVWF  48
1043:  CLRF   49
....................  
.................... char ton_c_track[] = "ton_c"; 
1044:  MOVLW  74
1045:  MOVWF  4A
1046:  MOVLW  6F
1047:  MOVWF  4B
1048:  MOVLW  6E
1049:  MOVWF  4C
104A:  MOVLW  5F
104B:  MOVWF  4D
104C:  MOVLW  63
104D:  MOVWF  4E
104E:  CLRF   4F
.................... char ton_d_track[] = "ton_d"; 
104F:  MOVLW  74
1050:  MOVWF  50
1051:  MOVLW  6F
1052:  MOVWF  51
1053:  MOVLW  6E
1054:  MOVWF  52
1055:  MOVLW  5F
1056:  MOVWF  53
1057:  MOVLW  64
1058:  MOVWF  54
1059:  CLRF   55
.................... char ton_e_track[] = "ton_e"; 
105A:  MOVLW  74
105B:  MOVWF  56
105C:  MOVLW  6F
105D:  MOVWF  57
105E:  MOVLW  6E
105F:  MOVWF  58
1060:  MOVLW  5F
1061:  MOVWF  59
1062:  MOVLW  65
1063:  MOVWF  5A
1064:  CLRF   5B
.................... char ton_f_track[] = "ton_f"; 
1065:  MOVLW  74
1066:  MOVWF  5C
1067:  MOVLW  6F
1068:  MOVWF  5D
1069:  MOVLW  6E
106A:  MOVWF  5E
106B:  MOVLW  5F
106C:  MOVWF  5F
106D:  MOVLW  66
106E:  MOVWF  60
106F:  CLRF   61
.................... char ton_g_track[] = "ton_g"; 
1070:  MOVLW  74
1071:  MOVWF  62
1072:  MOVLW  6F
1073:  MOVWF  63
1074:  MOVLW  6E
1075:  MOVWF  64
1076:  MOVLW  5F
1077:  MOVWF  65
1078:  MOVLW  67
1079:  MOVWF  66
107A:  CLRF   67
....................  
....................  
.................... char mootrack[] = "moo1"; 
107B:  MOVLW  6D
107C:  MOVWF  68
107D:  MOVLW  6F
107E:  MOVWF  69
107F:  MOVWF  6A
1080:  MOVLW  31
1081:  MOVWF  6B
1082:  CLRF   6C
.................... char horsetrack[] = "horse1"; 
1083:  MOVLW  68
1084:  BCF    03.5
1085:  BSF    03.6
1086:  MOVWF  10
1087:  MOVLW  6F
1088:  MOVWF  11
1089:  MOVLW  72
108A:  MOVWF  12
108B:  MOVLW  73
108C:  MOVWF  13
108D:  MOVLW  65
108E:  MOVWF  14
108F:  MOVLW  31
1090:  MOVWF  15
1091:  CLRF   16
.................... // char frogtrack[] = "frog1"; 
.................... char donkeytrack[] = "donkey1"; 
1092:  MOVLW  64
1093:  MOVWF  17
1094:  MOVLW  6F
1095:  MOVWF  18
1096:  MOVLW  6E
1097:  MOVWF  19
1098:  MOVLW  6B
1099:  MOVWF  1A
109A:  MOVLW  65
109B:  MOVWF  1B
109C:  MOVLW  79
109D:  MOVWF  1C
109E:  MOVLW  31
109F:  MOVWF  1D
10A0:  CLRF   1E
.................... char sheeptrack[] = "sheep1"; 
10A1:  MOVLW  73
10A2:  MOVWF  1F
10A3:  MOVLW  68
10A4:  MOVWF  20
10A5:  MOVLW  65
10A6:  MOVWF  21
10A7:  MOVWF  22
10A8:  MOVLW  70
10A9:  MOVWF  23
10AA:  MOVLW  31
10AB:  MOVWF  24
10AC:  CLRF   25
.................... char dogtrack[] = "dog1"; 
10AD:  MOVLW  64
10AE:  MOVWF  26
10AF:  MOVLW  6F
10B0:  MOVWF  27
10B1:  MOVLW  67
10B2:  MOVWF  28
10B3:  MOVLW  31
10B4:  MOVWF  29
10B5:  CLRF   2A
....................  
....................  
.................... char boing1track[] = "boing1"; 
10B6:  MOVLW  62
10B7:  MOVWF  2B
10B8:  MOVLW  6F
10B9:  MOVWF  2C
10BA:  MOVLW  69
10BB:  MOVWF  2D
10BC:  MOVLW  6E
10BD:  MOVWF  2E
10BE:  MOVLW  67
10BF:  MOVWF  2F
10C0:  MOVLW  31
10C1:  MOVWF  30
10C2:  CLRF   31
.................... char boing2track[] = "boing2"; 
10C3:  MOVLW  62
10C4:  MOVWF  32
10C5:  MOVLW  6F
10C6:  MOVWF  33
10C7:  MOVLW  69
10C8:  MOVWF  34
10C9:  MOVLW  6E
10CA:  MOVWF  35
10CB:  MOVLW  67
10CC:  MOVWF  36
10CD:  MOVLW  32
10CE:  MOVWF  37
10CF:  CLRF   38
.................... char boing3track[] = "boing3"; 
10D0:  MOVLW  62
10D1:  MOVWF  39
10D2:  MOVLW  6F
10D3:  MOVWF  3A
10D4:  MOVLW  69
10D5:  MOVWF  3B
10D6:  MOVLW  6E
10D7:  MOVWF  3C
10D8:  MOVLW  67
10D9:  MOVWF  3D
10DA:  MOVLW  33
10DB:  MOVWF  3E
10DC:  CLRF   3F
.................... char boing4track[] = "boing4"; 
10DD:  MOVLW  62
10DE:  MOVWF  40
10DF:  MOVLW  6F
10E0:  MOVWF  41
10E1:  MOVLW  69
10E2:  MOVWF  42
10E3:  MOVLW  6E
10E4:  MOVWF  43
10E5:  MOVLW  67
10E6:  MOVWF  44
10E7:  MOVLW  34
10E8:  MOVWF  45
10E9:  CLRF   46
.................... char boing5track[] = "boing5"; 
10EA:  MOVLW  62
10EB:  MOVWF  47
10EC:  MOVLW  6F
10ED:  MOVWF  48
10EE:  MOVLW  69
10EF:  MOVWF  49
10F0:  MOVLW  6E
10F1:  MOVWF  4A
10F2:  MOVLW  67
10F3:  MOVWF  4B
10F4:  MOVLW  35
10F5:  MOVWF  4C
10F6:  CLRF   4D
....................  
.................... char bell1track[] = "bell1"; 
10F7:  MOVLW  62
10F8:  MOVWF  4E
10F9:  MOVLW  65
10FA:  MOVWF  4F
10FB:  MOVLW  6C
10FC:  MOVWF  50
10FD:  MOVWF  51
10FE:  MOVLW  31
10FF:  MOVWF  52
1100:  CLRF   53
.................... char bell2track[] = "bell2"; 
1101:  MOVLW  62
1102:  MOVWF  54
1103:  MOVLW  65
1104:  MOVWF  55
1105:  MOVLW  6C
1106:  MOVWF  56
1107:  MOVWF  57
1108:  MOVLW  32
1109:  MOVWF  58
110A:  CLRF   59
.................... char bell3track[] = "bell3"; 
110B:  MOVLW  62
110C:  MOVWF  5A
110D:  MOVLW  65
110E:  MOVWF  5B
110F:  MOVLW  6C
1110:  MOVWF  5C
1111:  MOVWF  5D
1112:  MOVLW  33
1113:  MOVWF  5E
1114:  CLRF   5F
.................... char bell4track[] = "bell4"; 
1115:  MOVLW  62
1116:  MOVWF  60
1117:  MOVLW  65
1118:  MOVWF  61
1119:  MOVLW  6C
111A:  MOVWF  62
111B:  MOVWF  63
111C:  MOVLW  34
111D:  MOVWF  64
111E:  CLRF   65
.................... char bell5track[] = "bell5"; 
111F:  MOVLW  62
1120:  MOVWF  66
1121:  MOVLW  65
1122:  MOVWF  67
1123:  MOVLW  6C
1124:  MOVWF  68
1125:  MOVWF  69
1126:  MOVLW  35
1127:  MOVWF  6A
1128:  CLRF   6B
....................  
....................  
.................... // shared data storage 
.................... int programState; 
.................... int programStep; 
.................... int1 programSignal1; 
.................... int1 programSignal2; 
.................... int programWaiting = 0; 
1129:  CLRF   7C
....................  
....................  
.................... // included program definitions 
.................... #include "program1.c" 
....................  
....................  
.................... void program1_keydown(int key) 
.................... { 
.................... 	if (key == programStep) 
*
0816:  MOVF   76,W
0817:  SUBWF  1E,W
0818:  BTFSS  03.2
0819:  GOTO   03B
.................... 	{ 
.................... 	  mp3commandpush(MP3_CMD_STOP); 
081A:  MOVLW  04
081B:  MOVWF  35
081C:  BCF    0A.3
081D:  BCF    03.5
081E:  BCF    03.6
081F:  CALL   1E1
0820:  BSF    0A.3
....................       mp3commandpush(MP3_CMD_LOOP_OFF); 
0821:  MOVLW  16
0822:  BSF    03.5
0823:  BSF    03.6
0824:  MOVWF  35
0825:  BCF    0A.3
0826:  BCF    03.5
0827:  BCF    03.6
0828:  CALL   1E1
0829:  BSF    0A.3
.................... 	  mp3playtrack(fart1track); 
082A:  BSF    03.5
082B:  BSF    03.6
082C:  CLRF   34
082D:  MOVLW  C4
082E:  MOVWF  33
082F:  BCF    0A.3
0830:  BCF    03.5
0831:  BCF    03.6
0832:  CALL   242
0833:  BSF    0A.3
....................       programState = 2; 
0834:  MOVLW  02
0835:  MOVWF  75
.................... 	  programWaiting = 20; 
0836:  MOVLW  14
0837:  MOVWF  7C
.................... 	} else { 
0838:  GOTO   039
0839:  BSF    03.5
083A:  BSF    03.6
.................... 	} 
.................... } 
....................  
.................... void program1_start() 
.................... { 
....................   programState = 1; 
*
0237:  MOVLW  01
0238:  MOVWF  75
....................   programStep = 0; 
0239:  CLRF   76
....................   mp3commandpush(MP3_CMD_LOOP_ON); 
023A:  MOVLW  15
023B:  BSF    03.5
023C:  BSF    03.6
023D:  MOVWF  35
023E:  BCF    03.5
023F:  BCF    03.6
0240:  CALL   1E1
.................... } 
0241:  RETLW  00
....................  
.................... void program1_timer100msec() 
.................... { 
.................... 	button_led_off(programStep); 
*
0C69:  MOVF   76,W
0C6A:  BSF    03.5
0C6B:  BSF    03.6
0C6C:  MOVWF  1A
.................... 	if (programState == 1) // up 
*
0C7C:  DECFSZ 75,W
0C7D:  GOTO   488
....................     { 
.................... 		if (programStep == 5)  
0C7E:  MOVF   76,W
0C7F:  SUBLW  05
0C80:  BTFSS  03.2
0C81:  GOTO   486
.................... 		{ 
.................... 			programState = 0; // down 
0C82:  CLRF   75
.................... 			programStep = 4; 
0C83:  MOVLW  04
0C84:  MOVWF  76
.................... 		} else programStep ++; 
0C85:  GOTO   487
0C86:  INCF   76,F
....................  
.................... 	} else if (programState == 0) { 
0C87:  GOTO   49C
0C88:  MOVF   75,F
0C89:  BTFSS  03.2
0C8A:  GOTO   494
....................  
.................... 		if (programStep == 1)  
0C8B:  DECFSZ 76,W
0C8C:  GOTO   492
.................... 		{ 
.................... 			programState = 1; // up again 
0C8D:  MOVLW  01
0C8E:  MOVWF  75
.................... 			programStep = 2; 
0C8F:  MOVLW  02
0C90:  MOVWF  76
.................... 		} else programStep --; 
0C91:  GOTO   493
0C92:  DECF   76,F
....................  
....................     } else { // stopped 
0C93:  GOTO   49C
.................... 		if (programWaiting == 0)  
0C94:  MOVF   7C,F
0C95:  BTFSS  03.2
0C96:  GOTO   49B
.................... 		{ 
.................... 			program1_start(); 
0C97:  BCF    0A.3
0C98:  CALL   237
0C99:  BSF    0A.3
.................... 		} else programWaiting--; 
0C9A:  GOTO   49C
0C9B:  DECF   7C,F
.................... 	} 
.................... 	button_led_on(programStep); 
0C9C:  MOVF   76,W
0C9D:  BSF    03.5
0C9E:  BSF    03.6
0C9F:  MOVWF  20
0CA0:  BCF    0A.3
0CA1:  BCF    03.5
0CA2:  BCF    03.6
0CA3:  CALL   270
0CA4:  BSF    0A.3
.................... } 
....................  
.................... void program1_keyup(int key) 
.................... { 
....................  
.................... } 
....................  
....................  
.................... void program1_stop() 
.................... { 
....................   mp3commandpush(MP3_CMD_LOOP_OFF); 
*
0303:  MOVLW  16
0304:  BSF    03.5
0305:  BSF    03.6
0306:  MOVWF  35
0307:  BCF    03.5
0308:  BCF    03.6
0309:  CALL   1E1
....................   mp3commandpush(MP3_CMD_STOP); 
030A:  MOVLW  04
030B:  BSF    03.5
030C:  BSF    03.6
030D:  MOVWF  35
030E:  BCF    03.5
030F:  BCF    03.6
0310:  CALL   1E1
.................... } 
....................  
.................... void program1_mp3commandfinished(int command) 
.................... { 
....................   if (command == MP3_CMD_LOOP_ON) mp3playtrack(manc1track); 
*
0D45:  MOVF   1A,W
0D46:  SUBLW  15
0D47:  BTFSS  03.2
0D48:  GOTO   553
0D49:  CLRF   34
0D4A:  MOVLW  BE
0D4B:  MOVWF  33
0D4C:  BCF    0A.3
0D4D:  BCF    03.5
0D4E:  BCF    03.6
0D4F:  CALL   242
0D50:  BSF    0A.3
0D51:  BSF    03.5
0D52:  BSF    03.6
.................... } 
....................  
.................... void program1_sample_started(int sample) 
.................... { 
....................  
.................... } 
....................  
.................... void program1_sample_completed(int sample) 
.................... { 
....................  
.................... } 
....................  
.................... #include "program2.c" 
....................  
.................... void playnote(int key) 
.................... { 
.................... 	button_led_clearall(); 
*
0281:  CALL   157
.................... 	if (key == 5) { 
0282:  BSF    03.5
0283:  BSF    03.6
0284:  MOVF   1F,W
0285:  SUBLW  05
0286:  BTFSS  03.2
0287:  GOTO   291
.................... 		mp3playtrack(ton_c_track); 
0288:  CLRF   34
0289:  MOVLW  CA
028A:  MOVWF  33
028B:  BCF    03.5
028C:  BCF    03.6
028D:  CALL   242
....................     } 
....................     else if (key == 4) { 
028E:  GOTO   2C0
028F:  BSF    03.5
0290:  BSF    03.6
0291:  MOVF   1F,W
0292:  SUBLW  04
0293:  BTFSS  03.2
0294:  GOTO   29E
.................... 		mp3playtrack(ton_d_track); 
0295:  CLRF   34
0296:  MOVLW  D0
0297:  MOVWF  33
0298:  BCF    03.5
0299:  BCF    03.6
029A:  CALL   242
.................... 	} 
....................     else if (key == 3) { 
029B:  GOTO   2C0
029C:  BSF    03.5
029D:  BSF    03.6
029E:  MOVF   1F,W
029F:  SUBLW  03
02A0:  BTFSS  03.2
02A1:  GOTO   2AB
.................... 		mp3playtrack(ton_e_track); 
02A2:  CLRF   34
02A3:  MOVLW  D6
02A4:  MOVWF  33
02A5:  BCF    03.5
02A6:  BCF    03.6
02A7:  CALL   242
.................... 	} 
....................     else if (key == 2) { 
02A8:  GOTO   2C0
02A9:  BSF    03.5
02AA:  BSF    03.6
02AB:  MOVF   1F,W
02AC:  SUBLW  02
02AD:  BTFSS  03.2
02AE:  GOTO   2B8
.................... 		mp3playtrack(ton_f_track); 
02AF:  CLRF   34
02B0:  MOVLW  DC
02B1:  MOVWF  33
02B2:  BCF    03.5
02B3:  BCF    03.6
02B4:  CALL   242
.................... 	} 
....................     else if (key == 1) { 
02B5:  GOTO   2C0
02B6:  BSF    03.5
02B7:  BSF    03.6
02B8:  DECFSZ 1F,W
02B9:  GOTO   2C2
.................... 		mp3playtrack(ton_g_track); 
02BA:  CLRF   34
02BB:  MOVLW  E2
02BC:  MOVWF  33
02BD:  BCF    03.5
02BE:  BCF    03.6
02BF:  CALL   242
02C0:  BSF    03.5
02C1:  BSF    03.6
.................... 	} 
.................... 	button_led_on(key); 
02C2:  MOVF   1F,W
02C3:  MOVWF  20
02C4:  BCF    03.5
02C5:  BCF    03.6
02C6:  CALL   270
.................... } 
02C7:  RETLW  00
....................  
.................... void program2_keydown(int key) 
.................... { 
.................... 	playnote(key); 
*
0846:  MOVF   1E,W
0847:  MOVWF  1F
0848:  BCF    0A.3
0849:  BCF    03.5
084A:  BCF    03.6
084B:  CALL   281
084C:  BSF    0A.3
.................... } 
....................  
....................  
....................  
.................... void program2_timer100msec() 
.................... { 
.................... 	 
.................... } 
....................  
.................... void program2_keyup(int key) 
.................... { 
.................... 	mp3commandpush(MP3_CMD_STOP); 
*
0A72:  MOVLW  04
0A73:  MOVWF  35
0A74:  BCF    0A.3
0A75:  BCF    03.5
0A76:  BCF    03.6
0A77:  CALL   1E1
0A78:  BSF    0A.3
.................... 	button_led_clearall(); 
0A79:  BCF    0A.3
0A7A:  CALL   157
0A7B:  BSF    0A.3
.................... } 
....................  
.................... void program2_start() 
.................... { 
.................... 	mp3commandpush(MP3_CMD_LOOP_ON); 
*
03B6:  MOVLW  15
03B7:  BSF    03.5
03B8:  BSF    03.6
03B9:  MOVWF  35
03BA:  BCF    03.5
03BB:  BCF    03.6
03BC:  CALL   1E1
.................... } 
....................  
.................... void program2_sample_started(int sample) 
.................... { 
....................  
.................... } 
....................  
.................... void program2_sample_completed(int sample) 
.................... { 
....................  
.................... } 
....................  
.................... void program2_stop() 
.................... { 
....................   mp3commandpush(MP3_CMD_LOOP_OFF); 
*
0316:  MOVLW  16
0317:  BSF    03.5
0318:  BSF    03.6
0319:  MOVWF  35
031A:  BCF    03.5
031B:  BCF    03.6
031C:  CALL   1E1
....................   mp3commandpush(MP3_CMD_STOP); 
031D:  MOVLW  04
031E:  BSF    03.5
031F:  BSF    03.6
0320:  MOVWF  35
0321:  BCF    03.5
0322:  BCF    03.6
0323:  CALL   1E1
.................... } 
....................  
.................... void program2_mp3commandfinished(int command) 
.................... { 
.................... } 
....................  
.................... #include "program3.c" 
....................  
....................  
.................... int sequence[10] = { 4,2,1,5,3,1,3,4,2,5 }; 
*
112A:  MOVLW  04
112B:  BSF    03.5
112C:  MOVWF  10
112D:  MOVLW  02
112E:  MOVWF  11
112F:  MOVLW  01
1130:  MOVWF  12
1131:  MOVLW  05
1132:  MOVWF  13
1133:  MOVLW  03
1134:  MOVWF  14
1135:  MOVLW  01
1136:  MOVWF  15
1137:  MOVLW  03
1138:  MOVWF  16
1139:  MOVLW  04
113A:  MOVWF  17
113B:  MOVLW  02
113C:  MOVWF  18
113D:  MOVLW  05
113E:  MOVWF  19
.................... int sequencecurrent; 
....................  
.................... void program3_start() 
.................... { 
....................   mp3commandpush(MP3_CMD_LOOP_OFF); 
*
02C8:  MOVLW  16
02C9:  BSF    03.5
02CA:  BSF    03.6
02CB:  MOVWF  35
02CC:  BCF    03.5
02CD:  BCF    03.6
02CE:  CALL   1E1
.................... 	   
....................   programState = 1; 
02CF:  MOVLW  01
02D0:  MOVWF  75
....................   programStep = 0; 
02D1:  CLRF   76
....................   sequencecurrent = 0; 
02D2:  CLRF   7D
.................... /* 
....................   int i; 
....................   for (i = 0; i < 10; i++) 
....................   { 
.................... 	sequence[i] = rand(); 
....................   } 
.................... */ 
....................   playnote(sequence[sequencecurrent]); 
02D3:  MOVLW  90
02D4:  ADDWF  7D,W
02D5:  MOVWF  04
02D6:  BSF    03.7
02D7:  MOVF   00,W
02D8:  BSF    03.5
02D9:  BSF    03.6
02DA:  MOVWF  1D
02DB:  MOVWF  1F
02DC:  BCF    03.5
02DD:  BCF    03.6
02DE:  CALL   281
.................... } 
02DF:  RETLW  00
....................  
.................... void program3_keydown(int key) 
.................... { 
.................... 	if (programState == 2) 
*
0856:  MOVF   75,W
0857:  SUBLW  02
0858:  BTFSS  03.2
0859:  GOTO   07F
.................... 	{ 
.................... if (!mp3playing) { 
085A:  BCF    03.5
085B:  BCF    03.6
085C:  BTFSC  30.4
085D:  GOTO   07D
.................... 		if (key == sequence[sequencecurrent]) 
085E:  MOVLW  90
085F:  ADDWF  7D,W
0860:  MOVWF  04
0861:  BSF    03.7
0862:  MOVF   00,W
0863:  BSF    03.5
0864:  BSF    03.6
0865:  SUBWF  1E,W
0866:  BTFSS  03.2
0867:  GOTO   073
.................... 		{ 
.................... 			sequencecurrent++; 
0868:  INCF   7D,F
.................... 			playnote(key); 
0869:  MOVF   1E,W
086A:  MOVWF  1F
086B:  BCF    0A.3
086C:  BCF    03.5
086D:  BCF    03.6
086E:  CALL   281
086F:  BSF    0A.3
....................  
.................... 		} else { 
0870:  GOTO   07D
0871:  BSF    03.5
0872:  BSF    03.6
.................... 			 
.................... 			mp3playtrack(fart1track); 
0873:  CLRF   34
0874:  MOVLW  C4
0875:  MOVWF  33
0876:  BCF    0A.3
0877:  BCF    03.5
0878:  BCF    03.6
0879:  CALL   242
087A:  BSF    0A.3
.................... 			programState = 3; 
087B:  MOVLW  03
087C:  MOVWF  75
087D:  BSF    03.5
087E:  BSF    03.6
.................... 		} 
.................... } 
.................... 	} 
.................... } 
....................  
.................... void program3_timer100msec() 
.................... { 
.................... 	if (programWaiting > 0) 
*
0CAE:  MOVF   7C,F
0CAF:  BTFSC  03.2
0CB0:  GOTO   4D6
.................... 	{ 
.................... 		if (programWaiting == 1) 
0CB1:  DECFSZ 7C,W
0CB2:  GOTO   4D5
.................... 		{ 
.................... 			if (programState == 1) { // playback 
0CB3:  DECFSZ 75,W
0CB4:  GOTO   4C4
.................... 				playnote(sequence[sequencecurrent]); 
0CB5:  MOVLW  90
0CB6:  ADDWF  7D,W
0CB7:  MOVWF  04
0CB8:  BSF    03.7
0CB9:  MOVF   00,W
0CBA:  BSF    03.5
0CBB:  BSF    03.6
0CBC:  MOVWF  1A
0CBD:  MOVWF  1F
0CBE:  BCF    0A.3
0CBF:  BCF    03.5
0CC0:  BCF    03.6
0CC1:  CALL   281
0CC2:  BSF    0A.3
.................... 			} else if (programState == 2) { // read 
0CC3:  GOTO   4D3
0CC4:  MOVF   75,W
0CC5:  SUBLW  02
0CC6:  BTFSC  03.2
....................     		} else if (programState == 3) { // error 
0CC7:  GOTO   4D3
0CC8:  MOVF   75,W
0CC9:  SUBLW  03
0CCA:  BTFSC  03.2
.................... 			} else if (programState == 4) { // finished 
0CCB:  GOTO   4D3
0CCC:  MOVF   75,W
0CCD:  SUBLW  04
0CCE:  BTFSS  03.2
0CCF:  GOTO   4D3
.................... 				program3_start(); 
0CD0:  BCF    0A.3
0CD1:  CALL   2C8
0CD2:  BSF    0A.3
.................... 			} 
....................  
.................... 			programWaiting = 0; 
0CD3:  CLRF   7C
.................... 		}  else programWaiting--; 
0CD4:  GOTO   4D6
0CD5:  DECF   7C,F
....................  
.................... 	} 
....................  
.................... } 
....................  
.................... void program3_sample_completed(int sample) 
.................... { 
.................... 	button_led_clearall(); 
*
05E4:  BCF    03.5
05E5:  BCF    03.6
05E6:  CALL   157
....................  
.................... 	if (programState == 1) // play 
05E7:  DECFSZ 75,W
05E8:  GOTO   5FF
.................... 	{ 
.................... 		if (sequencecurrent < programStep) 
05E9:  MOVF   76,W
05EA:  SUBWF  7D,W
05EB:  BTFSC  03.0
05EC:  GOTO   5FB
.................... 		{ 
.................... 			sequencecurrent++; 
05ED:  INCF   7D,F
....................   			playnote(sequence[sequencecurrent]); 
05EE:  MOVLW  90
05EF:  ADDWF  7D,W
05F0:  MOVWF  04
05F1:  BSF    03.7
05F2:  MOVF   00,W
05F3:  BSF    03.5
05F4:  BSF    03.6
05F5:  MOVWF  1C
05F6:  MOVWF  1F
05F7:  BCF    03.5
05F8:  BCF    03.6
05F9:  CALL   281
....................   		} else { 
05FA:  GOTO   5FE
.................... 			programState = 2; 
05FB:  MOVLW  02
05FC:  MOVWF  75
.................... 			sequencecurrent = 0; 
05FD:  CLRF   7D
.................... 		} 
.................... 	} else if (programState == 2) { // read 
05FE:  GOTO   61F
05FF:  MOVF   75,W
0600:  SUBLW  02
0601:  BTFSS  03.2
0602:  GOTO   61F
....................  
.................... 		if (sequencecurrent <= programStep) { 
0603:  MOVF   7D,W
0604:  SUBWF  76,W
0605:  BTFSC  03.0
.................... 		//	sequencecurrent++; 
.................... 		} else { 
0606:  GOTO   61F
.................... 			if (programStep == 5) { 
0607:  MOVF   76,W
0608:  SUBLW  05
0609:  BTFSS  03.2
060A:  GOTO   619
.................... 				mp3playtrack(bell1track); 
060B:  MOVLW  01
060C:  BSF    03.5
060D:  BSF    03.6
060E:  MOVWF  34
060F:  MOVLW  4E
0610:  MOVWF  33
0611:  BCF    03.5
0612:  BCF    03.6
0613:  CALL   242
.................... 				programState = 4; 
0614:  MOVLW  04
0615:  MOVWF  75
.................... 				programWaiting = 20; 
0616:  MOVLW  14
0617:  MOVWF  7C
.................... 			} else { 
0618:  GOTO   61F
.................... 				programState = 1; 
0619:  MOVLW  01
061A:  MOVWF  75
.................... 				programStep++; 
061B:  INCF   76,F
.................... 				sequencecurrent = 0; 
061C:  CLRF   7D
.................... 				programWaiting = 7; 
061D:  MOVLW  07
061E:  MOVWF  7C
....................   				 
.................... 			} 
....................   		} 
.................... 		 
.................... 	} 
....................  
.................... } 
....................  
.................... void program3_keyup(int key) 
.................... { 
.................... } 
....................  
....................  
.................... void program3_sample_started(int sample) 
.................... { 
....................  
.................... } 
.................... void program3_stop() 
.................... { 
.................... 	mp3commandpush(MP3_CMD_STOP); 
*
0329:  MOVLW  04
032A:  BSF    03.5
032B:  BSF    03.6
032C:  MOVWF  35
032D:  BCF    03.5
032E:  BCF    03.6
032F:  CALL   1E1
.................... } 
....................  
.................... void program3_mp3commandfinished(int command) 
.................... { 
.................... } 
....................  
.................... #include "program4.c" 
....................  
.................... void program4_keydown(int key) 
.................... { 
.................... 	 
.................... 	if (key == 2) 
*
088A:  MOVF   1E,W
088B:  SUBLW  02
088C:  BTFSS  03.2
088D:  GOTO   0A2
....................     { 
....................      if (mp3playtrack(mootrack))	{ 
088E:  CLRF   34
088F:  MOVLW  E8
0890:  MOVWF  33
0891:  BCF    0A.3
0892:  BCF    03.5
0893:  BCF    03.6
0894:  CALL   242
0895:  BSF    0A.3
0896:  MOVF   78,F
0897:  BTFSC  03.2
0898:  GOTO   09F
....................         programState = key; 
0899:  BSF    03.5
089A:  BSF    03.6
089B:  MOVF   1E,W
089C:  MOVWF  75
089D:  BCF    03.5
089E:  BCF    03.6
....................      } 
.................... 	} 
....................     else if (key == 1) 
089F:  GOTO   101
08A0:  BSF    03.5
08A1:  BSF    03.6
08A2:  DECFSZ 1E,W
08A3:  GOTO   0B9
....................     { 
....................      if (mp3playtrack(donkeytrack))	{ 
08A4:  MOVLW  01
08A5:  MOVWF  34
08A6:  MOVLW  17
08A7:  MOVWF  33
08A8:  BCF    0A.3
08A9:  BCF    03.5
08AA:  BCF    03.6
08AB:  CALL   242
08AC:  BSF    0A.3
08AD:  MOVF   78,F
08AE:  BTFSC  03.2
08AF:  GOTO   0B6
....................         programState = key; 
08B0:  BSF    03.5
08B1:  BSF    03.6
08B2:  MOVF   1E,W
08B3:  MOVWF  75
08B4:  BCF    03.5
08B5:  BCF    03.6
....................      } 
.................... 	} 
....................     else if (key == 4) 
08B6:  GOTO   101
08B7:  BSF    03.5
08B8:  BSF    03.6
08B9:  MOVF   1E,W
08BA:  SUBLW  04
08BB:  BTFSS  03.2
08BC:  GOTO   0D2
....................     { 
....................      if (mp3playtrack(dogtrack))	{ 
08BD:  MOVLW  01
08BE:  MOVWF  34
08BF:  MOVLW  26
08C0:  MOVWF  33
08C1:  BCF    0A.3
08C2:  BCF    03.5
08C3:  BCF    03.6
08C4:  CALL   242
08C5:  BSF    0A.3
08C6:  MOVF   78,F
08C7:  BTFSC  03.2
08C8:  GOTO   0CF
....................         programState = key; 
08C9:  BSF    03.5
08CA:  BSF    03.6
08CB:  MOVF   1E,W
08CC:  MOVWF  75
08CD:  BCF    03.5
08CE:  BCF    03.6
....................      } 
.................... 	} 
....................     else if (key == 3) 
08CF:  GOTO   101
08D0:  BSF    03.5
08D1:  BSF    03.6
08D2:  MOVF   1E,W
08D3:  SUBLW  03
08D4:  BTFSS  03.2
08D5:  GOTO   0EB
....................     { 
....................      if (mp3playtrack(horsetrack))	{ 
08D6:  MOVLW  01
08D7:  MOVWF  34
08D8:  MOVLW  10
08D9:  MOVWF  33
08DA:  BCF    0A.3
08DB:  BCF    03.5
08DC:  BCF    03.6
08DD:  CALL   242
08DE:  BSF    0A.3
08DF:  MOVF   78,F
08E0:  BTFSC  03.2
08E1:  GOTO   0E8
....................         programState = key; 
08E2:  BSF    03.5
08E3:  BSF    03.6
08E4:  MOVF   1E,W
08E5:  MOVWF  75
08E6:  BCF    03.5
08E7:  BCF    03.6
....................      } 
.................... 	} 
....................     else if (key == 5) 
08E8:  GOTO   101
08E9:  BSF    03.5
08EA:  BSF    03.6
08EB:  MOVF   1E,W
08EC:  SUBLW  05
08ED:  BTFSS  03.2
08EE:  GOTO   0FF
....................     { 
....................      if (mp3playtrack(sheeptrack))	{ 
08EF:  MOVLW  01
08F0:  MOVWF  34
08F1:  MOVLW  1F
08F2:  MOVWF  33
08F3:  BCF    0A.3
08F4:  BCF    03.5
08F5:  BCF    03.6
08F6:  CALL   242
08F7:  BSF    0A.3
08F8:  MOVF   78,F
08F9:  BTFSC  03.2
08FA:  GOTO   101
....................         programState = key; 
08FB:  BSF    03.5
08FC:  BSF    03.6
08FD:  MOVF   1E,W
08FE:  MOVWF  75
08FF:  BCF    03.5
0900:  BCF    03.6
....................      } 
.................... 	} 
.................... } 
....................  
.................... void program4_timer100msec() 
.................... { 
.................... } 
....................  
.................... void program4_keyup(int key) 
.................... { 
....................  
.................... } 
....................  
.................... void program4_start() 
.................... { 
....................  
.................... } 
....................  
.................... void program4_sample_started(int sample) 
.................... { 
.................... 	button_led_on(programState); 
*
06C1:  MOVF   75,W
06C2:  MOVWF  20
06C3:  BCF    03.5
06C4:  BCF    03.6
06C5:  CALL   270
.................... } 
....................  
.................... void program4_sample_completed(int sample) 
.................... { 
.................... 	button_led_clearall(); 
*
0628:  BCF    03.5
0629:  BCF    03.6
062A:  CALL   157
.................... } 
....................  
.................... void program4_stop() 
.................... { 
.................... 	mp3commandpush(MP3_CMD_STOP); 
*
0335:  MOVLW  04
0336:  BSF    03.5
0337:  BSF    03.6
0338:  MOVWF  35
0339:  BCF    03.5
033A:  BCF    03.6
033B:  CALL   1E1
.................... } 
....................  
.................... void program4_mp3commandfinished(int command) 
.................... { 
....................  
.................... } 
....................  
.................... #include "program5.c" 
....................  
....................  
.................... void program5_keydown(int key) 
.................... { 
....................     if (key == 1) 
*
090A:  DECFSZ 1E,W
090B:  GOTO   121
....................     { 
....................      if (mp3playtrack(boing1track))	{ 
090C:  MOVLW  01
090D:  MOVWF  34
090E:  MOVLW  2B
090F:  MOVWF  33
0910:  BCF    0A.3
0911:  BCF    03.5
0912:  BCF    03.6
0913:  CALL   242
0914:  BSF    0A.3
0915:  MOVF   78,F
0916:  BTFSC  03.2
0917:  GOTO   11E
....................         programState = key; 
0918:  BSF    03.5
0919:  BSF    03.6
091A:  MOVF   1E,W
091B:  MOVWF  75
091C:  BCF    03.5
091D:  BCF    03.6
....................      } 
.................... 	} 
....................     else if (key == 2) 
091E:  GOTO   182
091F:  BSF    03.5
0920:  BSF    03.6
0921:  MOVF   1E,W
0922:  SUBLW  02
0923:  BTFSS  03.2
0924:  GOTO   13A
....................     { 
....................      if (mp3playtrack(boing2track))	{ 
0925:  MOVLW  01
0926:  MOVWF  34
0927:  MOVLW  32
0928:  MOVWF  33
0929:  BCF    0A.3
092A:  BCF    03.5
092B:  BCF    03.6
092C:  CALL   242
092D:  BSF    0A.3
092E:  MOVF   78,F
092F:  BTFSC  03.2
0930:  GOTO   137
....................         programState = key; 
0931:  BSF    03.5
0932:  BSF    03.6
0933:  MOVF   1E,W
0934:  MOVWF  75
0935:  BCF    03.5
0936:  BCF    03.6
....................      } 
.................... 	} 
....................     else if (key == 3) 
0937:  GOTO   182
0938:  BSF    03.5
0939:  BSF    03.6
093A:  MOVF   1E,W
093B:  SUBLW  03
093C:  BTFSS  03.2
093D:  GOTO   153
....................     { 
....................      if (mp3playtrack(boing3track))	{ 
093E:  MOVLW  01
093F:  MOVWF  34
0940:  MOVLW  39
0941:  MOVWF  33
0942:  BCF    0A.3
0943:  BCF    03.5
0944:  BCF    03.6
0945:  CALL   242
0946:  BSF    0A.3
0947:  MOVF   78,F
0948:  BTFSC  03.2
0949:  GOTO   150
....................         programState = key; 
094A:  BSF    03.5
094B:  BSF    03.6
094C:  MOVF   1E,W
094D:  MOVWF  75
094E:  BCF    03.5
094F:  BCF    03.6
....................      } 
.................... 	} 
....................     else if (key == 4) 
0950:  GOTO   182
0951:  BSF    03.5
0952:  BSF    03.6
0953:  MOVF   1E,W
0954:  SUBLW  04
0955:  BTFSS  03.2
0956:  GOTO   16C
....................     { 
....................      if (mp3playtrack(boing4track))	{ 
0957:  MOVLW  01
0958:  MOVWF  34
0959:  MOVLW  40
095A:  MOVWF  33
095B:  BCF    0A.3
095C:  BCF    03.5
095D:  BCF    03.6
095E:  CALL   242
095F:  BSF    0A.3
0960:  MOVF   78,F
0961:  BTFSC  03.2
0962:  GOTO   169
....................         programState = key; 
0963:  BSF    03.5
0964:  BSF    03.6
0965:  MOVF   1E,W
0966:  MOVWF  75
0967:  BCF    03.5
0968:  BCF    03.6
....................      } 
.................... 	} 
....................     else if (key == 5) 
0969:  GOTO   182
096A:  BSF    03.5
096B:  BSF    03.6
096C:  MOVF   1E,W
096D:  SUBLW  05
096E:  BTFSS  03.2
096F:  GOTO   180
....................     { 
....................      if (mp3playtrack(boing5track))	{ 
0970:  MOVLW  01
0971:  MOVWF  34
0972:  MOVLW  47
0973:  MOVWF  33
0974:  BCF    0A.3
0975:  BCF    03.5
0976:  BCF    03.6
0977:  CALL   242
0978:  BSF    0A.3
0979:  MOVF   78,F
097A:  BTFSC  03.2
097B:  GOTO   182
....................         programState = key; 
097C:  BSF    03.5
097D:  BSF    03.6
097E:  MOVF   1E,W
097F:  MOVWF  75
0980:  BCF    03.5
0981:  BCF    03.6
....................      } 
.................... 	} 
.................... } 
....................  
.................... void program5_timer100msec() 
.................... { 
.................... } 
....................  
.................... void program5_keyup(int key) 
.................... { 
....................  
.................... } 
....................  
.................... void program5_start() 
.................... { 
....................  
.................... } 
....................  
.................... void program5_sample_started(int sample) 
.................... { 
.................... 	button_led_on(programState); 
*
06CF:  MOVF   75,W
06D0:  MOVWF  20
06D1:  BCF    03.5
06D2:  BCF    03.6
06D3:  CALL   270
.................... } 
....................  
.................... void program5_sample_completed(int sample) 
.................... { 
....................     button_led_clearall(); 
*
0634:  BCF    03.5
0635:  BCF    03.6
0636:  CALL   157
.................... } 
....................  
.................... void program5_stop() 
.................... { 
.................... 	mp3commandpush(MP3_CMD_STOP); 
*
0341:  MOVLW  04
0342:  BSF    03.5
0343:  BSF    03.6
0344:  MOVWF  35
0345:  BCF    03.5
0346:  BCF    03.6
0347:  CALL   1E1
.................... } 
....................  
.................... void program5_mp3commandfinished(int command) 
.................... { 
.................... } 
....................  
.................... #include "program6.c" 
....................  
....................  
.................... void program6_keydown(int key) 
.................... { 
....................     if (key == 1) 
*
098B:  DECFSZ 1E,W
098C:  GOTO   1A2
....................     { 
....................      if (mp3playtrack(bell1track))	{ 
098D:  MOVLW  01
098E:  MOVWF  34
098F:  MOVLW  4E
0990:  MOVWF  33
0991:  BCF    0A.3
0992:  BCF    03.5
0993:  BCF    03.6
0994:  CALL   242
0995:  BSF    0A.3
0996:  MOVF   78,F
0997:  BTFSC  03.2
0998:  GOTO   19F
....................         programState = key; 
0999:  BSF    03.5
099A:  BSF    03.6
099B:  MOVF   1E,W
099C:  MOVWF  75
099D:  BCF    03.5
099E:  BCF    03.6
....................      } 
.................... 	} 
....................     else if (key == 2) 
099F:  GOTO   203
09A0:  BSF    03.5
09A1:  BSF    03.6
09A2:  MOVF   1E,W
09A3:  SUBLW  02
09A4:  BTFSS  03.2
09A5:  GOTO   1BB
....................     { 
....................      if (mp3playtrack(bell2track))	{ 
09A6:  MOVLW  01
09A7:  MOVWF  34
09A8:  MOVLW  54
09A9:  MOVWF  33
09AA:  BCF    0A.3
09AB:  BCF    03.5
09AC:  BCF    03.6
09AD:  CALL   242
09AE:  BSF    0A.3
09AF:  MOVF   78,F
09B0:  BTFSC  03.2
09B1:  GOTO   1B8
....................         programState = key; 
09B2:  BSF    03.5
09B3:  BSF    03.6
09B4:  MOVF   1E,W
09B5:  MOVWF  75
09B6:  BCF    03.5
09B7:  BCF    03.6
....................      } 
.................... 	} 
....................     else if (key == 3) 
09B8:  GOTO   203
09B9:  BSF    03.5
09BA:  BSF    03.6
09BB:  MOVF   1E,W
09BC:  SUBLW  03
09BD:  BTFSS  03.2
09BE:  GOTO   1D4
....................     { 
....................      if (mp3playtrack(bell3track))	{ 
09BF:  MOVLW  01
09C0:  MOVWF  34
09C1:  MOVLW  5A
09C2:  MOVWF  33
09C3:  BCF    0A.3
09C4:  BCF    03.5
09C5:  BCF    03.6
09C6:  CALL   242
09C7:  BSF    0A.3
09C8:  MOVF   78,F
09C9:  BTFSC  03.2
09CA:  GOTO   1D1
....................         programState = key; 
09CB:  BSF    03.5
09CC:  BSF    03.6
09CD:  MOVF   1E,W
09CE:  MOVWF  75
09CF:  BCF    03.5
09D0:  BCF    03.6
....................      } 
.................... 	} 
....................     else if (key == 4) 
09D1:  GOTO   203
09D2:  BSF    03.5
09D3:  BSF    03.6
09D4:  MOVF   1E,W
09D5:  SUBLW  04
09D6:  BTFSS  03.2
09D7:  GOTO   1ED
....................     { 
....................      if (mp3playtrack(bell4track))	{ 
09D8:  MOVLW  01
09D9:  MOVWF  34
09DA:  MOVLW  60
09DB:  MOVWF  33
09DC:  BCF    0A.3
09DD:  BCF    03.5
09DE:  BCF    03.6
09DF:  CALL   242
09E0:  BSF    0A.3
09E1:  MOVF   78,F
09E2:  BTFSC  03.2
09E3:  GOTO   1EA
....................         programState = key; 
09E4:  BSF    03.5
09E5:  BSF    03.6
09E6:  MOVF   1E,W
09E7:  MOVWF  75
09E8:  BCF    03.5
09E9:  BCF    03.6
....................      } 
.................... 	} 
....................     else if (key == 5) 
09EA:  GOTO   203
09EB:  BSF    03.5
09EC:  BSF    03.6
09ED:  MOVF   1E,W
09EE:  SUBLW  05
09EF:  BTFSS  03.2
09F0:  GOTO   201
....................     { 
....................      if (mp3playtrack(bell5track))	{ 
09F1:  MOVLW  01
09F2:  MOVWF  34
09F3:  MOVLW  66
09F4:  MOVWF  33
09F5:  BCF    0A.3
09F6:  BCF    03.5
09F7:  BCF    03.6
09F8:  CALL   242
09F9:  BSF    0A.3
09FA:  MOVF   78,F
09FB:  BTFSC  03.2
09FC:  GOTO   203
....................         programState = key; 
09FD:  BSF    03.5
09FE:  BSF    03.6
09FF:  MOVF   1E,W
0A00:  MOVWF  75
0A01:  BCF    03.5
0A02:  BCF    03.6
....................      } 
.................... 	} 
.................... } 
....................  
.................... void program6_timer100msec() 
.................... { 
.................... } 
....................  
.................... void program6_keyup(int key) 
.................... { 
....................  
.................... } 
....................  
.................... void program6_start() 
.................... { 
....................  
.................... } 
....................  
.................... void program6_sample_started(int sample) 
.................... { 
.................... 	button_led_on(programState); 
*
06DD:  MOVF   75,W
06DE:  MOVWF  20
06DF:  BCF    03.5
06E0:  BCF    03.6
06E1:  CALL   270
.................... } 
....................  
.................... void program6_sample_completed(int sample) 
.................... { 
....................     button_led_clearall(); 
*
0640:  BCF    03.5
0641:  BCF    03.6
0642:  CALL   157
.................... } 
....................  
.................... void program6_stop() 
.................... { 
.................... 	mp3commandpush(MP3_CMD_STOP); 
*
034D:  MOVLW  04
034E:  BSF    03.5
034F:  BSF    03.6
0350:  MOVWF  35
0351:  BCF    03.5
0352:  BCF    03.6
0353:  CALL   1E1
.................... } 
....................  
.................... void program6_mp3commandfinished(int command) 
.................... { 
.................... } 
....................  
.................... #include "program7.c" 
....................  
.................... void program7_keydown(int key) 
.................... { 
.................... 	char title[20]; 
.................... 	sprintf(title, "lied_%u_%u", program_running,key); 
*
078B:  MOVLW  01
078C:  BSF    03.5
078D:  MOVWF  6E
078E:  MOVLW  9F
078F:  MOVWF  6D
0790:  BSF    03.6
0791:  CLRF   33
0792:  MOVF   33,W
0793:  BCF    03.5
0794:  BCF    03.6
0795:  CALL   0CB
0796:  BSF    03.5
0797:  BSF    03.6
0798:  INCF   33,F
0799:  MOVWF  77
079A:  MOVWF  36
079B:  BCF    03.5
079C:  BCF    03.6
079D:  CALL   731
079E:  MOVLW  05
079F:  BSF    03.5
07A0:  BSF    03.6
07A1:  SUBWF  33,W
07A2:  BTFSS  03.2
07A3:  GOTO   792
07A4:  BCF    03.5
07A5:  BCF    03.6
07A6:  MOVF   2F,W
07A7:  BSF    03.5
07A8:  BSF    03.6
07A9:  MOVWF  34
07AA:  MOVLW  1B
07AB:  MOVWF  35
07AC:  BCF    03.5
07AD:  BCF    03.6
07AE:  CALL   742
07AF:  MOVLW  5F
07B0:  BSF    03.5
07B1:  BSF    03.6
07B2:  MOVWF  36
07B3:  BCF    03.5
07B4:  BCF    03.6
07B5:  CALL   731
07B6:  BSF    03.5
07B7:  BSF    03.6
07B8:  MOVF   1E,W
07B9:  MOVWF  34
07BA:  MOVLW  1B
07BB:  MOVWF  35
07BC:  BCF    03.5
07BD:  BCF    03.6
07BE:  CALL   742
.................... 	if (mp3playtrack(title))	{ 
07BF:  MOVLW  01
07C0:  BSF    03.5
07C1:  BSF    03.6
07C2:  MOVWF  34
07C3:  MOVLW  9F
07C4:  MOVWF  33
07C5:  BCF    03.5
07C6:  BCF    03.6
07C7:  CALL   242
07C8:  MOVF   78,F
07C9:  BTFSC  03.2
07CA:  GOTO   7D1
....................     	programState = key; 
07CB:  BSF    03.5
07CC:  BSF    03.6
07CD:  MOVF   1E,W
07CE:  MOVWF  75
07CF:  BCF    03.5
07D0:  BCF    03.6
....................     } 
.................... } 
07D1:  RETLW  00
....................  
.................... void program7_timer100msec() 
.................... { 
.................... } 
*
07F6:  RETLW  00
....................  
.................... void program7_keyup(int key) 
.................... { 
....................  
.................... } 
*
07D2:  RETLW  00
....................  
.................... void program7_start() 
.................... { 
....................  
.................... } 
*
02E0:  RETLW  00
....................  
.................... void program7_sample_started(int sample) 
.................... { 
.................... 	button_led_on(programState); 
*
0692:  MOVF   75,W
0693:  BSF    03.5
0694:  BSF    03.6
0695:  MOVWF  20
0696:  BCF    03.5
0697:  BCF    03.6
0698:  CALL   270
.................... } 
0699:  RETLW  00
....................  
.................... void program7_sample_completed(int sample) 
.................... { 
.................... 	button_led_clearall(); 
*
05C6:  CALL   157
.................... } 
05C7:  RETLW  00
....................  
.................... void program7_stop() 
.................... { 
.................... 	mp3commandpush(MP3_CMD_STOP); 
*
022F:  MOVLW  04
0230:  BSF    03.5
0231:  BSF    03.6
0232:  MOVWF  35
0233:  BCF    03.5
0234:  BCF    03.6
0235:  CALL   1E1
.................... } 
0236:  RETLW  00
....................  
.................... void program7_mp3commandfinished(int command) 
.................... { 
....................  
.................... } 
....................  
....................  
.................... // shared entry methods 
.................... void program_keydown(int key) 
.................... { 
.................... 	if (program_running == 1) program1_keydown(key); 
*
080E:  BCF    03.5
080F:  BCF    03.6
0810:  DECFSZ 2F,W
0811:  GOTO   03E
0812:  BSF    03.5
0813:  BSF    03.6
0814:  MOVF   1D,W
0815:  MOVWF  1E
.................... 	else if (program_running == 2) program2_keydown(key); 
*
083B:  GOTO   259
083C:  BCF    03.5
083D:  BCF    03.6
083E:  MOVF   2F,W
083F:  SUBLW  02
0840:  BTFSS  03.2
0841:  GOTO   04E
0842:  BSF    03.5
0843:  BSF    03.6
0844:  MOVF   1D,W
0845:  MOVWF  1E
.................... 	else if (program_running == 3) program3_keydown(key); 
*
084D:  GOTO   257
084E:  MOVF   2F,W
084F:  SUBLW  03
0850:  BTFSS  03.2
0851:  GOTO   082
0852:  BSF    03.5
0853:  BSF    03.6
0854:  MOVF   1D,W
0855:  MOVWF  1E
.................... 	else if (program_running == 4) program4_keydown(key); 
*
087F:  GOTO   259
0880:  BCF    03.5
0881:  BCF    03.6
0882:  MOVF   2F,W
0883:  SUBLW  04
0884:  BTFSS  03.2
0885:  GOTO   102
0886:  BSF    03.5
0887:  BSF    03.6
0888:  MOVF   1D,W
0889:  MOVWF  1E
.................... 	else if (program_running == 5) program5_keydown(key); 
*
0901:  GOTO   257
0902:  MOVF   2F,W
0903:  SUBLW  05
0904:  BTFSS  03.2
0905:  GOTO   183
0906:  BSF    03.5
0907:  BSF    03.6
0908:  MOVF   1D,W
0909:  MOVWF  1E
.................... 	else if (program_running == 6) program6_keydown(key); 
*
0982:  GOTO   257
0983:  MOVF   2F,W
0984:  SUBLW  06
0985:  BTFSS  03.2
0986:  GOTO   204
0987:  BSF    03.5
0988:  BSF    03.6
0989:  MOVF   1D,W
098A:  MOVWF  1E
.................... 	else if (program_running == 7) program7_keydown(key); 
*
0A03:  GOTO   257
0A04:  MOVF   2F,W
0A05:  SUBLW  07
0A06:  BTFSS  03.2
0A07:  GOTO   212
0A08:  BSF    03.5
0A09:  BSF    03.6
0A0A:  MOVF   1D,W
0A0B:  MOVWF  1E
0A0C:  BCF    0A.3
0A0D:  BCF    03.5
0A0E:  BCF    03.6
0A0F:  CALL   78B
0A10:  BSF    0A.3
.................... 	else if (program_running == 8) program7_keydown(key); 
0A11:  GOTO   257
0A12:  MOVF   2F,W
0A13:  SUBLW  08
0A14:  BTFSS  03.2
0A15:  GOTO   220
0A16:  BSF    03.5
0A17:  BSF    03.6
0A18:  MOVF   1D,W
0A19:  MOVWF  1E
0A1A:  BCF    0A.3
0A1B:  BCF    03.5
0A1C:  BCF    03.6
0A1D:  CALL   78B
0A1E:  BSF    0A.3
.................... 	else if (program_running == 9) program7_keydown(key); 
0A1F:  GOTO   257
0A20:  MOVF   2F,W
0A21:  SUBLW  09
0A22:  BTFSS  03.2
0A23:  GOTO   22E
0A24:  BSF    03.5
0A25:  BSF    03.6
0A26:  MOVF   1D,W
0A27:  MOVWF  1E
0A28:  BCF    0A.3
0A29:  BCF    03.5
0A2A:  BCF    03.6
0A2B:  CALL   78B
0A2C:  BSF    0A.3
.................... 	else if (program_running == 10) program7_keydown(key); 
0A2D:  GOTO   257
0A2E:  MOVF   2F,W
0A2F:  SUBLW  0A
0A30:  BTFSS  03.2
0A31:  GOTO   23C
0A32:  BSF    03.5
0A33:  BSF    03.6
0A34:  MOVF   1D,W
0A35:  MOVWF  1E
0A36:  BCF    0A.3
0A37:  BCF    03.5
0A38:  BCF    03.6
0A39:  CALL   78B
0A3A:  BSF    0A.3
.................... 	else if (program_running == 11) program7_keydown(key); 
0A3B:  GOTO   257
0A3C:  MOVF   2F,W
0A3D:  SUBLW  0B
0A3E:  BTFSS  03.2
0A3F:  GOTO   24A
0A40:  BSF    03.5
0A41:  BSF    03.6
0A42:  MOVF   1D,W
0A43:  MOVWF  1E
0A44:  BCF    0A.3
0A45:  BCF    03.5
0A46:  BCF    03.6
0A47:  CALL   78B
0A48:  BSF    0A.3
.................... 	else if (program_running == 12) program7_keydown(key); 
0A49:  GOTO   257
0A4A:  MOVF   2F,W
0A4B:  SUBLW  0C
0A4C:  BTFSS  03.2
0A4D:  GOTO   257
0A4E:  BSF    03.5
0A4F:  BSF    03.6
0A50:  MOVF   1D,W
0A51:  MOVWF  1E
0A52:  BCF    0A.3
0A53:  BCF    03.5
0A54:  BCF    03.6
0A55:  CALL   78B
0A56:  BSF    0A.3
0A57:  BSF    03.5
0A58:  BSF    03.6
....................  
.................... } 
....................  
.................... void program_timer100msec() 
.................... { 
.................... 	if (program_running == 1) program1_timer100msec(); 
*
0C67:  DECFSZ 2F,W
0C68:  GOTO   4A6
.................... 	else if (program_running == 2) program2_timer100msec(); 
*
0CA5:  GOTO   512
0CA6:  MOVF   2F,W
0CA7:  SUBLW  02
0CA8:  BTFSC  03.2
.................... 	else if (program_running == 3) program3_timer100msec(); 
0CA9:  GOTO   512
0CAA:  MOVF   2F,W
0CAB:  SUBLW  03
0CAC:  BTFSS  03.2
0CAD:  GOTO   4D7
.................... 	else if (program_running == 4) program4_timer100msec(); 
*
0CD6:  GOTO   512
0CD7:  MOVF   2F,W
0CD8:  SUBLW  04
0CD9:  BTFSC  03.2
.................... 	else if (program_running == 5) program5_timer100msec(); 
0CDA:  GOTO   512
0CDB:  MOVF   2F,W
0CDC:  SUBLW  05
0CDD:  BTFSC  03.2
.................... 	else if (program_running == 6) program6_timer100msec(); 
0CDE:  GOTO   512
0CDF:  MOVF   2F,W
0CE0:  SUBLW  06
0CE1:  BTFSC  03.2
.................... 	else if (program_running == 7) program7_timer100msec(); 
0CE2:  GOTO   512
0CE3:  MOVF   2F,W
0CE4:  SUBLW  07
0CE5:  BTFSS  03.2
0CE6:  GOTO   4EB
0CE7:  BCF    0A.3
0CE8:  CALL   7F6
0CE9:  BSF    0A.3
.................... 	else if (program_running == 8) program7_timer100msec(); 
0CEA:  GOTO   512
0CEB:  MOVF   2F,W
0CEC:  SUBLW  08
0CED:  BTFSS  03.2
0CEE:  GOTO   4F3
0CEF:  BCF    0A.3
0CF0:  CALL   7F6
0CF1:  BSF    0A.3
.................... 	else if (program_running == 9) program7_timer100msec(); 
0CF2:  GOTO   512
0CF3:  MOVF   2F,W
0CF4:  SUBLW  09
0CF5:  BTFSS  03.2
0CF6:  GOTO   4FB
0CF7:  BCF    0A.3
0CF8:  CALL   7F6
0CF9:  BSF    0A.3
.................... 	else if (program_running == 10) program7_timer100msec(); 
0CFA:  GOTO   512
0CFB:  MOVF   2F,W
0CFC:  SUBLW  0A
0CFD:  BTFSS  03.2
0CFE:  GOTO   503
0CFF:  BCF    0A.3
0D00:  CALL   7F6
0D01:  BSF    0A.3
.................... 	else if (program_running == 11) program7_timer100msec(); 
0D02:  GOTO   512
0D03:  MOVF   2F,W
0D04:  SUBLW  0B
0D05:  BTFSS  03.2
0D06:  GOTO   50B
0D07:  BCF    0A.3
0D08:  CALL   7F6
0D09:  BSF    0A.3
.................... 	else if (program_running == 12) program7_timer100msec(); 
0D0A:  GOTO   512
0D0B:  MOVF   2F,W
0D0C:  SUBLW  0C
0D0D:  BTFSS  03.2
0D0E:  GOTO   512
0D0F:  BCF    0A.3
0D10:  CALL   7F6
0D11:  BSF    0A.3
.................... } 
0D12:  BCF    0A.3
0D13:  BSF    0A.4
0D14:  GOTO   310 (RETURN)
....................  
.................... void program_keyup(int key) 
.................... { 
.................... 	if (program_running == 1) program1_keyup(key); 
*
0A5F:  BCF    03.5
0A60:  BCF    03.6
0A61:  DECFSZ 2F,W
0A62:  GOTO   26A
0A63:  BSF    03.5
0A64:  BSF    03.6
0A65:  MOVF   1D,W
0A66:  MOVWF  1E
.................... 	else if (program_running == 2) program2_keyup(key); 
0A67:  GOTO   2FE
0A68:  BCF    03.5
0A69:  BCF    03.6
0A6A:  MOVF   2F,W
0A6B:  SUBLW  02
0A6C:  BTFSS  03.2
0A6D:  GOTO   27D
0A6E:  BSF    03.5
0A6F:  BSF    03.6
0A70:  MOVF   1D,W
0A71:  MOVWF  1E
.................... 	else if (program_running == 3) program3_keyup(key); 
*
0A7C:  GOTO   2FC
0A7D:  MOVF   2F,W
0A7E:  SUBLW  03
0A7F:  BTFSS  03.2
0A80:  GOTO   288
0A81:  BSF    03.5
0A82:  BSF    03.6
0A83:  MOVF   1D,W
0A84:  MOVWF  1E
.................... 	else if (program_running == 4) program4_keyup(key); 
0A85:  GOTO   2FE
0A86:  BCF    03.5
0A87:  BCF    03.6
0A88:  MOVF   2F,W
0A89:  SUBLW  04
0A8A:  BTFSS  03.2
0A8B:  GOTO   293
0A8C:  BSF    03.5
0A8D:  BSF    03.6
0A8E:  MOVF   1D,W
0A8F:  MOVWF  1E
.................... 	else if (program_running == 5) program5_keyup(key); 
0A90:  GOTO   2FE
0A91:  BCF    03.5
0A92:  BCF    03.6
0A93:  MOVF   2F,W
0A94:  SUBLW  05
0A95:  BTFSS  03.2
0A96:  GOTO   29E
0A97:  BSF    03.5
0A98:  BSF    03.6
0A99:  MOVF   1D,W
0A9A:  MOVWF  1E
.................... 	else if (program_running == 6) program6_keyup(key); 
0A9B:  GOTO   2FE
0A9C:  BCF    03.5
0A9D:  BCF    03.6
0A9E:  MOVF   2F,W
0A9F:  SUBLW  06
0AA0:  BTFSS  03.2
0AA1:  GOTO   2A9
0AA2:  BSF    03.5
0AA3:  BSF    03.6
0AA4:  MOVF   1D,W
0AA5:  MOVWF  1E
.................... 	else if (program_running == 7) program7_keyup(key); 
0AA6:  GOTO   2FE
0AA7:  BCF    03.5
0AA8:  BCF    03.6
0AA9:  MOVF   2F,W
0AAA:  SUBLW  07
0AAB:  BTFSS  03.2
0AAC:  GOTO   2B7
0AAD:  BSF    03.5
0AAE:  BSF    03.6
0AAF:  MOVF   1D,W
0AB0:  MOVWF  1E
0AB1:  BCF    0A.3
0AB2:  BCF    03.5
0AB3:  BCF    03.6
0AB4:  CALL   7D2
0AB5:  BSF    0A.3
.................... 	else if (program_running == 8) program7_keyup(key); 
0AB6:  GOTO   2FC
0AB7:  MOVF   2F,W
0AB8:  SUBLW  08
0AB9:  BTFSS  03.2
0ABA:  GOTO   2C5
0ABB:  BSF    03.5
0ABC:  BSF    03.6
0ABD:  MOVF   1D,W
0ABE:  MOVWF  1E
0ABF:  BCF    0A.3
0AC0:  BCF    03.5
0AC1:  BCF    03.6
0AC2:  CALL   7D2
0AC3:  BSF    0A.3
.................... 	else if (program_running == 9) program7_keyup(key); 
0AC4:  GOTO   2FC
0AC5:  MOVF   2F,W
0AC6:  SUBLW  09
0AC7:  BTFSS  03.2
0AC8:  GOTO   2D3
0AC9:  BSF    03.5
0ACA:  BSF    03.6
0ACB:  MOVF   1D,W
0ACC:  MOVWF  1E
0ACD:  BCF    0A.3
0ACE:  BCF    03.5
0ACF:  BCF    03.6
0AD0:  CALL   7D2
0AD1:  BSF    0A.3
.................... 	else if (program_running == 10) program7_keyup(key); 
0AD2:  GOTO   2FC
0AD3:  MOVF   2F,W
0AD4:  SUBLW  0A
0AD5:  BTFSS  03.2
0AD6:  GOTO   2E1
0AD7:  BSF    03.5
0AD8:  BSF    03.6
0AD9:  MOVF   1D,W
0ADA:  MOVWF  1E
0ADB:  BCF    0A.3
0ADC:  BCF    03.5
0ADD:  BCF    03.6
0ADE:  CALL   7D2
0ADF:  BSF    0A.3
.................... 	else if (program_running == 11) program7_keyup(key); 
0AE0:  GOTO   2FC
0AE1:  MOVF   2F,W
0AE2:  SUBLW  0B
0AE3:  BTFSS  03.2
0AE4:  GOTO   2EF
0AE5:  BSF    03.5
0AE6:  BSF    03.6
0AE7:  MOVF   1D,W
0AE8:  MOVWF  1E
0AE9:  BCF    0A.3
0AEA:  BCF    03.5
0AEB:  BCF    03.6
0AEC:  CALL   7D2
0AED:  BSF    0A.3
.................... 	else if (program_running == 12) program7_keyup(key); 
0AEE:  GOTO   2FC
0AEF:  MOVF   2F,W
0AF0:  SUBLW  0C
0AF1:  BTFSS  03.2
0AF2:  GOTO   2FC
0AF3:  BSF    03.5
0AF4:  BSF    03.6
0AF5:  MOVF   1D,W
0AF6:  MOVWF  1E
0AF7:  BCF    0A.3
0AF8:  BCF    03.5
0AF9:  BCF    03.6
0AFA:  CALL   7D2
0AFB:  BSF    0A.3
0AFC:  BSF    03.5
0AFD:  BSF    03.6
.................... } 
....................  
.................... void program_start(int programId) 
.................... { 
.................... 	random_update(programId); 
*
02E1:  BSF    03.5
02E2:  BSF    03.6
02E3:  MOVF   1C,W
02E4:  MOVWF  1D
....................  
.................... 	if (programId <= MAX_PROGRAM) 
*
02F9:  BSF    03.5
02FA:  BSF    03.6
02FB:  MOVF   1C,W
02FC:  SUBLW  0C
02FD:  BTFSS  03.0
02FE:  GOTO   3F4
.................... 	{ 
.................... 		if (program_running == 1) program1_stop(); 
02FF:  BCF    03.5
0300:  BCF    03.6
0301:  DECFSZ 2F,W
0302:  GOTO   312
.................... 		else if (program_running == 2) program2_stop(); 
*
0311:  GOTO   377
0312:  MOVF   2F,W
0313:  SUBLW  02
0314:  BTFSS  03.2
0315:  GOTO   325
.................... 		else if (program_running == 3) program3_stop(); 
*
0324:  GOTO   377
0325:  MOVF   2F,W
0326:  SUBLW  03
0327:  BTFSS  03.2
0328:  GOTO   331
.................... 		else if (program_running == 4) program4_stop(); 
*
0330:  GOTO   377
0331:  MOVF   2F,W
0332:  SUBLW  04
0333:  BTFSS  03.2
0334:  GOTO   33D
.................... 		else if (program_running == 5) program5_stop(); 
*
033C:  GOTO   377
033D:  MOVF   2F,W
033E:  SUBLW  05
033F:  BTFSS  03.2
0340:  GOTO   349
.................... 		else if (program_running == 6) program6_stop(); 
*
0348:  GOTO   377
0349:  MOVF   2F,W
034A:  SUBLW  06
034B:  BTFSS  03.2
034C:  GOTO   355
.................... 		else if (program_running == 7) program7_stop(); 
*
0354:  GOTO   377
0355:  MOVF   2F,W
0356:  SUBLW  07
0357:  BTFSS  03.2
0358:  GOTO   35B
0359:  CALL   22F
.................... 		else if (program_running == 8) program7_stop(); 
035A:  GOTO   377
035B:  MOVF   2F,W
035C:  SUBLW  08
035D:  BTFSS  03.2
035E:  GOTO   361
035F:  CALL   22F
.................... 		else if (program_running == 9) program7_stop(); 
0360:  GOTO   377
0361:  MOVF   2F,W
0362:  SUBLW  09
0363:  BTFSS  03.2
0364:  GOTO   367
0365:  CALL   22F
.................... 		else if (program_running == 10) program7_stop(); 
0366:  GOTO   377
0367:  MOVF   2F,W
0368:  SUBLW  0A
0369:  BTFSS  03.2
036A:  GOTO   36D
036B:  CALL   22F
.................... 		else if (program_running == 11) program7_stop(); 
036C:  GOTO   377
036D:  MOVF   2F,W
036E:  SUBLW  0B
036F:  BTFSS  03.2
0370:  GOTO   373
0371:  CALL   22F
.................... 		else if (program_running == 12) program7_stop(); 
0372:  GOTO   377
0373:  MOVF   2F,W
0374:  SUBLW  0C
0375:  BTFSC  03.2
0376:  CALL   22F
....................  
.................... 		if (program_running != programId) 
0377:  BSF    03.5
0378:  BSF    03.6
0379:  MOVF   1C,W
037A:  BCF    03.5
037B:  BCF    03.6
037C:  SUBWF  2F,W
037D:  BTFSC  03.2
037E:  GOTO   3A2
.................... 		{ 
.................... 			program_running = programId; 
037F:  BSF    03.5
0380:  BSF    03.6
0381:  MOVF   1C,W
0382:  BCF    03.5
0383:  BCF    03.6
0384:  MOVWF  2F
....................  
.................... 			write_eeprom(EEPROM_RUNNING_PROGRAM,program_running); 
0385:  MOVLW  05
0386:  BSF    03.6
0387:  MOVWF  0D
0388:  BCF    03.6
0389:  MOVF   2F,W
038A:  BSF    03.6
038B:  MOVWF  0C
038C:  BSF    03.5
038D:  BCF    0C.7
038E:  BSF    0C.2
038F:  BCF    03.5
0390:  BCF    03.6
0391:  MOVF   0B,W
0392:  MOVWF  77
0393:  BCF    0B.7
0394:  BSF    03.5
0395:  BSF    03.6
0396:  MOVLW  55
0397:  MOVWF  0D
0398:  MOVLW  AA
0399:  MOVWF  0D
039A:  BSF    0C.1
039B:  BTFSC  0C.1
039C:  GOTO   39B
039D:  BCF    0C.2
039E:  MOVF   77,W
039F:  BCF    03.5
03A0:  BCF    03.6
03A1:  IORWF  0B,F
.................... 		} 
....................  
.................... 		set_kbd_lamp(program_running); 
03A2:  MOVF   2F,W
03A3:  BSF    03.5
03A4:  BSF    03.6
03A5:  MOVWF  1D
03A6:  BCF    03.5
03A7:  BCF    03.6
03A8:  CALL   172
....................  
.................... 		programState = 0; 
03A9:  CLRF   75
.................... 		programStep = 0; 
03AA:  CLRF   76
.................... 		programSignal1 = 0; 
03AB:  BCF    30.5
.................... 		programSignal2 = 0; 
03AC:  BCF    30.6
....................  
.................... 		button_led_clearall(); 
03AD:  CALL   157
....................  
.................... 		if (program_running == 1) program1_start(); 
03AE:  DECFSZ 2F,W
03AF:  GOTO   3B2
03B0:  CALL   237
.................... 		else if (program_running == 2) program2_start(); 
03B1:  GOTO   3F2
03B2:  MOVF   2F,W
03B3:  SUBLW  02
03B4:  BTFSS  03.2
03B5:  GOTO   3BE
.................... 		else if (program_running == 3) program3_start(); 
*
03BD:  GOTO   3F2
03BE:  MOVF   2F,W
03BF:  SUBLW  03
03C0:  BTFSS  03.2
03C1:  GOTO   3C4
03C2:  CALL   2C8
.................... 		else if (program_running == 4) program4_start(); 
03C3:  GOTO   3F2
03C4:  MOVF   2F,W
03C5:  SUBLW  04
03C6:  BTFSC  03.2
.................... 		else if (program_running == 5) program5_start(); 
03C7:  GOTO   3F2
03C8:  MOVF   2F,W
03C9:  SUBLW  05
03CA:  BTFSC  03.2
.................... 		else if (program_running == 6) program6_start(); 
03CB:  GOTO   3F2
03CC:  MOVF   2F,W
03CD:  SUBLW  06
03CE:  BTFSC  03.2
.................... 		else if (program_running == 7) program7_start(); 
03CF:  GOTO   3F2
03D0:  MOVF   2F,W
03D1:  SUBLW  07
03D2:  BTFSS  03.2
03D3:  GOTO   3D6
03D4:  CALL   2E0
.................... 		else if (program_running == 8) program7_start(); 
03D5:  GOTO   3F2
03D6:  MOVF   2F,W
03D7:  SUBLW  08
03D8:  BTFSS  03.2
03D9:  GOTO   3DC
03DA:  CALL   2E0
.................... 		else if (program_running == 9) program7_start(); 
03DB:  GOTO   3F2
03DC:  MOVF   2F,W
03DD:  SUBLW  09
03DE:  BTFSS  03.2
03DF:  GOTO   3E2
03E0:  CALL   2E0
.................... 		else if (program_running == 10) program7_start(); 
03E1:  GOTO   3F2
03E2:  MOVF   2F,W
03E3:  SUBLW  0A
03E4:  BTFSS  03.2
03E5:  GOTO   3E8
03E6:  CALL   2E0
.................... 		else if (program_running == 11) program7_start(); 
03E7:  GOTO   3F2
03E8:  MOVF   2F,W
03E9:  SUBLW  0B
03EA:  BTFSS  03.2
03EB:  GOTO   3EE
03EC:  CALL   2E0
.................... 		else if (program_running == 12) program7_start(); 
03ED:  GOTO   3F2
03EE:  MOVF   2F,W
03EF:  SUBLW  0C
03F0:  BTFSC  03.2
03F1:  CALL   2E0
03F2:  BSF    03.5
03F3:  BSF    03.6
....................  
....................  	} 
.................... } 
03F4:  BCF    03.5
03F5:  BCF    03.6
03F6:  RETLW  00
....................  
.................... void program_sample_started(int sample) 
.................... { 
.................... 	if (program_running == 1) program1_sample_started(sample); 
*
069A:  DECFSZ 2F,W
069B:  GOTO   6A3
069C:  BSF    03.5
069D:  BSF    03.6
069E:  MOVF   1A,W
069F:  MOVWF  1B
.................... 	else if (program_running == 2) program2_sample_started(sample); 
06A0:  GOTO   72C
06A1:  BCF    03.5
06A2:  BCF    03.6
06A3:  MOVF   2F,W
06A4:  SUBLW  02
06A5:  BTFSS  03.2
06A6:  GOTO   6AE
06A7:  BSF    03.5
06A8:  BSF    03.6
06A9:  MOVF   1A,W
06AA:  MOVWF  1B
.................... 	else if (program_running == 3) program3_sample_started(sample); 
06AB:  GOTO   72C
06AC:  BCF    03.5
06AD:  BCF    03.6
06AE:  MOVF   2F,W
06AF:  SUBLW  03
06B0:  BTFSS  03.2
06B1:  GOTO   6B9
06B2:  BSF    03.5
06B3:  BSF    03.6
06B4:  MOVF   1A,W
06B5:  MOVWF  1B
.................... 	else if (program_running == 4) program4_sample_started(sample); 
06B6:  GOTO   72C
06B7:  BCF    03.5
06B8:  BCF    03.6
06B9:  MOVF   2F,W
06BA:  SUBLW  04
06BB:  BTFSS  03.2
06BC:  GOTO   6C7
06BD:  BSF    03.5
06BE:  BSF    03.6
06BF:  MOVF   1A,W
06C0:  MOVWF  1B
.................... 	else if (program_running == 5) program5_sample_started(sample); 
*
06C6:  GOTO   72A
06C7:  MOVF   2F,W
06C8:  SUBLW  05
06C9:  BTFSS  03.2
06CA:  GOTO   6D5
06CB:  BSF    03.5
06CC:  BSF    03.6
06CD:  MOVF   1A,W
06CE:  MOVWF  1B
.................... 	else if (program_running == 6) program6_sample_started(sample); 
*
06D4:  GOTO   72A
06D5:  MOVF   2F,W
06D6:  SUBLW  06
06D7:  BTFSS  03.2
06D8:  GOTO   6E3
06D9:  BSF    03.5
06DA:  BSF    03.6
06DB:  MOVF   1A,W
06DC:  MOVWF  1B
.................... 	else if (program_running == 7) program7_sample_started(sample); 
*
06E2:  GOTO   72A
06E3:  MOVF   2F,W
06E4:  SUBLW  07
06E5:  BTFSS  03.2
06E6:  GOTO   6EF
06E7:  BSF    03.5
06E8:  BSF    03.6
06E9:  MOVF   1A,W
06EA:  MOVWF  1B
06EB:  BCF    03.5
06EC:  BCF    03.6
06ED:  CALL   692
.................... 	else if (program_running == 8) program7_sample_started(sample); 
06EE:  GOTO   72A
06EF:  MOVF   2F,W
06F0:  SUBLW  08
06F1:  BTFSS  03.2
06F2:  GOTO   6FB
06F3:  BSF    03.5
06F4:  BSF    03.6
06F5:  MOVF   1A,W
06F6:  MOVWF  1B
06F7:  BCF    03.5
06F8:  BCF    03.6
06F9:  CALL   692
.................... 	else if (program_running == 9) program7_sample_started(sample); 
06FA:  GOTO   72A
06FB:  MOVF   2F,W
06FC:  SUBLW  09
06FD:  BTFSS  03.2
06FE:  GOTO   707
06FF:  BSF    03.5
0700:  BSF    03.6
0701:  MOVF   1A,W
0702:  MOVWF  1B
0703:  BCF    03.5
0704:  BCF    03.6
0705:  CALL   692
.................... 	else if (program_running == 10) program7_sample_started(sample); 
0706:  GOTO   72A
0707:  MOVF   2F,W
0708:  SUBLW  0A
0709:  BTFSS  03.2
070A:  GOTO   713
070B:  BSF    03.5
070C:  BSF    03.6
070D:  MOVF   1A,W
070E:  MOVWF  1B
070F:  BCF    03.5
0710:  BCF    03.6
0711:  CALL   692
.................... 	else if (program_running == 11) program7_sample_started(sample); 
0712:  GOTO   72A
0713:  MOVF   2F,W
0714:  SUBLW  0B
0715:  BTFSS  03.2
0716:  GOTO   71F
0717:  BSF    03.5
0718:  BSF    03.6
0719:  MOVF   1A,W
071A:  MOVWF  1B
071B:  BCF    03.5
071C:  BCF    03.6
071D:  CALL   692
.................... 	else if (program_running == 12) program7_sample_started(sample); 
071E:  GOTO   72A
071F:  MOVF   2F,W
0720:  SUBLW  0C
0721:  BTFSS  03.2
0722:  GOTO   72A
0723:  BSF    03.5
0724:  BSF    03.6
0725:  MOVF   1A,W
0726:  MOVWF  1B
0727:  BCF    03.5
0728:  BCF    03.6
0729:  CALL   692
072A:  BSF    03.5
072B:  BSF    03.6
.................... } 
072C:  BCF    03.6
072D:  BCF    03.5
072E:  BCF    0A.3
072F:  BSF    0A.4
0730:  GOTO   2DC (RETURN)
....................  
.................... void program_sample_completed(int sample) 
.................... { 
.................... 	if (program_running == 1) program1_sample_completed(sample); 
*
05C8:  DECFSZ 2F,W
05C9:  GOTO   5D1
05CA:  BSF    03.5
05CB:  BSF    03.6
05CC:  MOVF   1A,W
05CD:  MOVWF  1B
.................... 	else if (program_running == 2) program2_sample_completed(sample); 
05CE:  GOTO   68D
05CF:  BCF    03.5
05D0:  BCF    03.6
05D1:  MOVF   2F,W
05D2:  SUBLW  02
05D3:  BTFSS  03.2
05D4:  GOTO   5DC
05D5:  BSF    03.5
05D6:  BSF    03.6
05D7:  MOVF   1A,W
05D8:  MOVWF  1B
.................... 	else if (program_running == 3) program3_sample_completed(sample); 
05D9:  GOTO   68D
05DA:  BCF    03.5
05DB:  BCF    03.6
05DC:  MOVF   2F,W
05DD:  SUBLW  03
05DE:  BTFSS  03.2
05DF:  GOTO   620
05E0:  BSF    03.5
05E1:  BSF    03.6
05E2:  MOVF   1A,W
05E3:  MOVWF  1B
.................... 	else if (program_running == 4) program4_sample_completed(sample); 
*
061F:  GOTO   68B
0620:  MOVF   2F,W
0621:  SUBLW  04
0622:  BTFSS  03.2
0623:  GOTO   62C
0624:  BSF    03.5
0625:  BSF    03.6
0626:  MOVF   1A,W
0627:  MOVWF  1B
.................... 	else if (program_running == 5) program5_sample_completed(sample); 
*
062B:  GOTO   68B
062C:  MOVF   2F,W
062D:  SUBLW  05
062E:  BTFSS  03.2
062F:  GOTO   638
0630:  BSF    03.5
0631:  BSF    03.6
0632:  MOVF   1A,W
0633:  MOVWF  1B
.................... 	else if (program_running == 6) program6_sample_completed(sample); 
*
0637:  GOTO   68B
0638:  MOVF   2F,W
0639:  SUBLW  06
063A:  BTFSS  03.2
063B:  GOTO   644
063C:  BSF    03.5
063D:  BSF    03.6
063E:  MOVF   1A,W
063F:  MOVWF  1B
.................... 	else if (program_running == 7) program7_sample_completed(sample); 
*
0643:  GOTO   68B
0644:  MOVF   2F,W
0645:  SUBLW  07
0646:  BTFSS  03.2
0647:  GOTO   650
0648:  BSF    03.5
0649:  BSF    03.6
064A:  MOVF   1A,W
064B:  MOVWF  1B
064C:  BCF    03.5
064D:  BCF    03.6
064E:  CALL   5C6
.................... 	else if (program_running == 8) program7_sample_completed(sample); 
064F:  GOTO   68B
0650:  MOVF   2F,W
0651:  SUBLW  08
0652:  BTFSS  03.2
0653:  GOTO   65C
0654:  BSF    03.5
0655:  BSF    03.6
0656:  MOVF   1A,W
0657:  MOVWF  1B
0658:  BCF    03.5
0659:  BCF    03.6
065A:  CALL   5C6
.................... 	else if (program_running == 9) program7_sample_completed(sample); 
065B:  GOTO   68B
065C:  MOVF   2F,W
065D:  SUBLW  09
065E:  BTFSS  03.2
065F:  GOTO   668
0660:  BSF    03.5
0661:  BSF    03.6
0662:  MOVF   1A,W
0663:  MOVWF  1B
0664:  BCF    03.5
0665:  BCF    03.6
0666:  CALL   5C6
.................... 	else if (program_running == 10) program7_sample_completed(sample); 
0667:  GOTO   68B
0668:  MOVF   2F,W
0669:  SUBLW  0A
066A:  BTFSS  03.2
066B:  GOTO   674
066C:  BSF    03.5
066D:  BSF    03.6
066E:  MOVF   1A,W
066F:  MOVWF  1B
0670:  BCF    03.5
0671:  BCF    03.6
0672:  CALL   5C6
.................... 	else if (program_running == 11) program7_sample_completed(sample); 
0673:  GOTO   68B
0674:  MOVF   2F,W
0675:  SUBLW  0B
0676:  BTFSS  03.2
0677:  GOTO   680
0678:  BSF    03.5
0679:  BSF    03.6
067A:  MOVF   1A,W
067B:  MOVWF  1B
067C:  BCF    03.5
067D:  BCF    03.6
067E:  CALL   5C6
.................... 	else if (program_running == 12) program7_sample_completed(sample); 
067F:  GOTO   68B
0680:  MOVF   2F,W
0681:  SUBLW  0C
0682:  BTFSS  03.2
0683:  GOTO   68B
0684:  BSF    03.5
0685:  BSF    03.6
0686:  MOVF   1A,W
0687:  MOVWF  1B
0688:  BCF    03.5
0689:  BCF    03.6
068A:  CALL   5C6
068B:  BSF    03.5
068C:  BSF    03.6
.................... } 
068D:  BCF    03.6
068E:  BCF    03.5
068F:  BCF    0A.3
0690:  BSF    0A.4
0691:  GOTO   2D1 (RETURN)
....................  
.................... //********************************************************** 
.................... // MP3-PLAYER SERIAL COMMUNICATIONS 
.................... //********************************************************** 
....................  
.................... void doserial() 
.................... { 
....................     if (mp3received) { 
*
0D15:  BTFSS  30.3
0D16:  GOTO   58C
....................   //   fprintf(terminal,"R:%S!",mp3buffer); // echo to terminal 
....................       mp3received = 0; 
0D17:  BCF    30.3
....................  
....................       if (mp3buffer[0] == 'E') { // fehlermeldung!! 
0D18:  MOVF   42,W
0D19:  SUBLW  45
0D1A:  BTFSS  03.2
0D1B:  GOTO   527
.................... 		button_led_on(5); 
0D1C:  MOVLW  05
0D1D:  BSF    03.5
0D1E:  BSF    03.6
0D1F:  MOVWF  20
0D20:  BCF    0A.3
0D21:  BCF    03.5
0D22:  BCF    03.6
0D23:  CALL   270
0D24:  BSF    0A.3
....................         mp3completed = 0; 
0D25:  CLRF   64
....................  
....................       } else { 
0D26:  GOTO   53C
....................  
....................        if (mp3status == MP3_CMD_PLAY) { 
0D27:  MOVF   63,W
0D28:  SUBLW  03
0D29:  BTFSS  03.2
0D2A:  GOTO   52B
....................          //mp3playing = 1; 
....................        } 
....................  
....................        if (mp3status == MP3_CMD_STOP) { 
0D2B:  MOVF   63,W
0D2C:  SUBLW  04
0D2D:  BTFSS  03.2
0D2E:  GOTO   531
.................... 		if (mp3playing) { 
0D2F:  BTFSS  30.4
0D30:  GOTO   531
....................         // mp3playing = 0; 
.................... 		// program_sample_completed(0); 
.................... 	    } 
....................        } 
....................  
....................        if (mp3status == MP3_CMD_QUERY_LENGTH) { 
0D31:  MOVF   63,W
0D32:  SUBLW  10
0D33:  BTFSS  03.2
0D34:  GOTO   535
....................        } 
....................  
....................        if (mp3status == MP3_CMD_QUERY_STATUS) { 
0D35:  DECFSZ 63,W
0D36:  GOTO   53C
....................         if (mp3buffer[0] == 'S') { 
0D37:  MOVF   42,W
0D38:  SUBLW  53
0D39:  BTFSS  03.2
0D3A:  GOTO   53C
....................          mp3playing = 0; 
0D3B:  BCF    30.4
....................         } // if (mp3buffer[0] == 'S') 
....................        } // if (mp3status == MP3_STATUS_QUERIED) 
....................  
....................  
....................       } // if (mp3buffer[0] == 'E') / else 
....................  
....................       mp3completed = mp3status;  // status fr folgeaktionen aufbewahren 
0D3C:  MOVF   63,W
0D3D:  MOVWF  64
....................       mp3status = MP3_STATUS_READY; // neues kommando ist zulssig 
0D3E:  CLRF   63
....................  
....................       if (program_running == 1) program1_mp3commandfinished(mp3completed); 
0D3F:  DECFSZ 2F,W
0D40:  GOTO   556
0D41:  MOVF   64,W
0D42:  BSF    03.5
0D43:  BSF    03.6
0D44:  MOVWF  1A
....................       else if (program_running == 2) program2_mp3commandfinished(mp3completed); 
*
0D53:  GOTO   58A
0D54:  BCF    03.5
0D55:  BCF    03.6
0D56:  MOVF   2F,W
0D57:  SUBLW  02
0D58:  BTFSS  03.2
0D59:  GOTO   561
0D5A:  MOVF   64,W
0D5B:  BSF    03.5
0D5C:  BSF    03.6
0D5D:  MOVWF  1A
....................       else if (program_running == 3) program3_mp3commandfinished(mp3completed); 
0D5E:  GOTO   58A
0D5F:  BCF    03.5
0D60:  BCF    03.6
0D61:  MOVF   2F,W
0D62:  SUBLW  03
0D63:  BTFSS  03.2
0D64:  GOTO   56C
0D65:  MOVF   64,W
0D66:  BSF    03.5
0D67:  BSF    03.6
0D68:  MOVWF  1A
....................       else if (program_running == 4) program4_mp3commandfinished(mp3completed); 
0D69:  GOTO   58A
0D6A:  BCF    03.5
0D6B:  BCF    03.6
0D6C:  MOVF   2F,W
0D6D:  SUBLW  04
0D6E:  BTFSS  03.2
0D6F:  GOTO   577
0D70:  MOVF   64,W
0D71:  BSF    03.5
0D72:  BSF    03.6
0D73:  MOVWF  1A
....................       else if (program_running == 5) program5_mp3commandfinished(mp3completed); 
0D74:  GOTO   58A
0D75:  BCF    03.5
0D76:  BCF    03.6
0D77:  MOVF   2F,W
0D78:  SUBLW  05
0D79:  BTFSS  03.2
0D7A:  GOTO   582
0D7B:  MOVF   64,W
0D7C:  BSF    03.5
0D7D:  BSF    03.6
0D7E:  MOVWF  1A
....................       else if (program_running == 6) program6_mp3commandfinished(mp3completed); 
0D7F:  GOTO   58A
0D80:  BCF    03.5
0D81:  BCF    03.6
0D82:  MOVF   2F,W
0D83:  SUBLW  06
0D84:  BTFSS  03.2
0D85:  GOTO   58C
0D86:  MOVF   64,W
0D87:  BSF    03.5
0D88:  BSF    03.6
0D89:  MOVWF  1A
0D8A:  BCF    03.5
0D8B:  BCF    03.6
....................       
....................     } // if (bkbhit)  
....................  } 
0D8C:  BCF    0A.3
0D8D:  BSF    0A.4
0D8E:  GOTO   32D (RETURN)
....................  
....................  
.................... /********************************************************** 
.................... / KEYBOARD 
.................... /**********************************************************/ 
....................  
.................... void dokeyaction(int key) 
.................... { 
....................    if ((key & MBIT_ID_MASK) == MBIT_ID_BUTTONPUSH) 
*
0800:  BSF    03.5
0801:  BSF    03.6
0802:  MOVF   1B,W
0803:  ANDLW  C0
0804:  SUBLW  80
0805:  BTFSS  03.2
0806:  GOTO   2FF
....................    { 
....................    	   if (key & MBIT_MAKE) 
0807:  BTFSS  1B.4
0808:  GOTO   25A
....................        { 
.................... 		program_keydown(key & MBIT_CODE_MASK); 
0809:  MOVF   1B,W
080A:  ANDLW  0F
080B:  MOVWF  1C
080C:  MOVF   1C,W
080D:  MOVWF  1D
....................        } else { 
*
0A59:  GOTO   2FE
.................... 		program_keyup(key & MBIT_CODE_MASK); 
0A5A:  MOVF   1B,W
0A5B:  ANDLW  0F
0A5C:  MOVWF  1C
0A5D:  MOVF   1C,W
0A5E:  MOVWF  1D
....................        } 
....................    }  
....................  
....................    else  
*
0AFE:  GOTO   31E
....................  
....................    if ((key & MBIT_ID_MASK) == MBIT_ID_KEYBOARD) 
0AFF:  MOVF   1B,W
0B00:  ANDLW  C0
0B01:  BTFSS  03.2
0B02:  GOTO   31E
....................    { 
....................    	   if (key & MBIT_MAKE) 
0B03:  BTFSS  1B.4
0B04:  GOTO   31E
....................        { 
....................         key = (key & MBIT_CODE_MASK); 
0B05:  MOVLW  0F
0B06:  ANDWF  1B,F
....................  
....................         if (key <= MAX_PROGRAM) 
0B07:  MOVF   1B,W
0B08:  SUBLW  0C
0B09:  BTFSS  03.0
0B0A:  GOTO   31D
....................         { 
....................            if (key != program_running) 
0B0B:  BCF    03.5
0B0C:  BCF    03.6
0B0D:  MOVF   2F,W
0B0E:  BSF    03.5
0B0F:  BSF    03.6
0B10:  SUBWF  1B,W
0B11:  BTFSC  03.2
0B12:  GOTO   31C
....................            { 
....................               program_start(key); 
0B13:  MOVF   1B,W
0B14:  MOVWF  1C
0B15:  BCF    0A.3
0B16:  BCF    03.5
0B17:  BCF    03.6
0B18:  CALL   2E1
0B19:  BSF    0A.3
0B1A:  BSF    03.5
0B1B:  BSF    03.6
....................            } 
....................         } else { 
0B1C:  GOTO   31D
.................... 			// if (key == 11) program_start(program_running); 
.................... 		} 
....................        } else { 
0B1D:  GOTO   31E
....................  
....................        } 
....................    } 
....................  
.................... } 
0B1E:  BCF    03.6
0B1F:  BCF    03.5
0B20:  BCF    0A.3
0B21:  BSF    0A.4
0B22:  GOTO   2F3 (RETURN)
....................  
.................... int1 busy_went_down = 0; 
*
1142:  BCF    03.5
1143:  BCF    30.7
.................... int1 busy_went_up = 0; 
1144:  BCF    7E.0
....................  
.................... #INT_EXT 
.................... void isr_intext() 
.................... { 
.................... 	if ((input_b() & 0x1)) { 
*
0148:  BTFSS  06.0
0149:  GOTO   14F
.................... 	 busy_went_up = 1; 
014A:  BSF    7E.0
.................... 	 ext_int_edge(H_TO_L);   
014B:  BSF    03.5
014C:  BCF    01.6
.................... 	} else { 
014D:  GOTO   152
014E:  BCF    03.5
.................... 	 busy_went_down = 1; 
014F:  BSF    30.7
.................... 	 ext_int_edge(L_TO_H);   
0150:  BSF    03.5
0151:  BSF    01.6
.................... 	}   
.................... } 
....................  
....................  
.................... /********************************************************** 
.................... / MAIN 
.................... /**********************************************************/ 
0152:  BCF    03.5
0153:  BCF    0B.1
0154:  BCF    0A.3
0155:  BCF    0A.4
0156:  GOTO   029
.................... void main() 
.................... { 
*
1000:  CLRF   04
1001:  BCF    03.7
1002:  MOVLW  1F
1003:  ANDWF  03,F
1004:  MOVLW  81
1005:  BSF    03.5
1006:  MOVWF  19
1007:  MOVLW  A6
1008:  MOVWF  18
1009:  MOVLW  90
100A:  BCF    03.5
100B:  MOVWF  18
100C:  BSF    03.5
100D:  BSF    1F.0
100E:  BSF    1F.1
100F:  BSF    1F.2
1010:  BCF    1F.3
....................  
....................    //int8 y = 0; 
....................     
....................    setup_adc(ADC_OFF); 
*
1145:  BCF    1F.0
....................    setup_adc_ports(NO_ANALOGS); 
1146:  BSF    03.5
1147:  BSF    1F.0
1148:  BSF    1F.1
1149:  BSF    1F.2
114A:  BCF    1F.3
....................  
....................    output_a(0x00); 
114B:  BCF    03.5
114C:  CLRF   05
....................    output_b(0x00); 
114D:  CLRF   06
....................    output_c(0x00); 
114E:  CLRF   07
....................    output_d(0x00); 
114F:  CLRF   08
....................    output_e(0x00); 
1150:  CLRF   09
....................  
....................    set_tris_a(0b00000000); // button leds 
1151:  MOVLW  00
1152:  BSF    03.5
1153:  MOVWF  05
....................    set_tris_b(0b00000001); // keyboard leds, mp3 busy (B0) 
1154:  MOVLW  01
1155:  MOVWF  06
....................    set_tris_c(0b10111110); // kommunikation und buttons 
1156:  MOVLW  BE
1157:  MOVWF  07
....................    set_tris_e(0b00000111); // E0: Keboard Lock 
1158:  BSF    09.0
1159:  BSF    09.1
115A:  BSF    09.2
....................  
....................    ext_int_edge(L_TO_H);     
115B:  BSF    01.6
....................  
....................    setup_timer_1(T1_INTERNAL | T1_DIV_BY_1 );    // Start timer 1 
115C:  MOVLW  85
115D:  BCF    03.5
115E:  MOVWF  10
....................    enable_interrupts(INT_TIMER1); 
115F:  BSF    03.5
1160:  BSF    0C.0
....................    enable_interrupts(INT_RDA); 
1161:  BSF    0C.5
....................    enable_interrupts(INT_EXT); 
1162:  BCF    03.5
1163:  BSF    0B.4
....................    enable_interrupts(global); 
1164:  MOVLW  C0
1165:  IORWF  0B,F
....................  
....................    button_led_clearall(); 
1166:  BCF    0A.4
1167:  CALL   157
1168:  BSF    0A.4
....................  
....................    set_kbd_lamp(12); 
1169:  MOVLW  0C
116A:  BSF    03.5
116B:  BSF    03.6
116C:  MOVWF  1D
116D:  BCF    0A.4
116E:  BCF    03.5
116F:  BCF    03.6
1170:  CALL   172
1171:  BSF    0A.4
....................    delay_ms(300);  
1172:  MOVLW  02
1173:  BSF    03.5
1174:  BSF    03.6
1175:  MOVWF  1A
1176:  MOVLW  96
1177:  MOVWF  1B
1178:  BCF    0A.4
1179:  BCF    03.5
117A:  BCF    03.6
117B:  CALL   1CD
117C:  BSF    0A.4
117D:  BSF    03.5
117E:  BSF    03.6
117F:  DECFSZ 1A,F
1180:  GOTO   176
....................    set_kbd_lamp(11); 
1181:  MOVLW  0B
1182:  MOVWF  1D
1183:  BCF    0A.4
1184:  BCF    03.5
1185:  BCF    03.6
1186:  CALL   172
1187:  BSF    0A.4
....................    delay_ms(300);  
1188:  MOVLW  02
1189:  BSF    03.5
118A:  BSF    03.6
118B:  MOVWF  1A
118C:  MOVLW  96
118D:  MOVWF  1B
118E:  BCF    0A.4
118F:  BCF    03.5
1190:  BCF    03.6
1191:  CALL   1CD
1192:  BSF    0A.4
1193:  BSF    03.5
1194:  BSF    03.6
1195:  DECFSZ 1A,F
1196:  GOTO   18C
....................    set_kbd_lamp(10); 
1197:  MOVLW  0A
1198:  MOVWF  1D
1199:  BCF    0A.4
119A:  BCF    03.5
119B:  BCF    03.6
119C:  CALL   172
119D:  BSF    0A.4
....................    delay_ms(300);  
119E:  MOVLW  02
119F:  BSF    03.5
11A0:  BSF    03.6
11A1:  MOVWF  1A
11A2:  MOVLW  96
11A3:  MOVWF  1B
11A4:  BCF    0A.4
11A5:  BCF    03.5
11A6:  BCF    03.6
11A7:  CALL   1CD
11A8:  BSF    0A.4
11A9:  BSF    03.5
11AA:  BSF    03.6
11AB:  DECFSZ 1A,F
11AC:  GOTO   1A2
....................    set_kbd_lamp(9); 
11AD:  MOVLW  09
11AE:  MOVWF  1D
11AF:  BCF    0A.4
11B0:  BCF    03.5
11B1:  BCF    03.6
11B2:  CALL   172
11B3:  BSF    0A.4
....................    delay_ms(300);  
11B4:  MOVLW  02
11B5:  BSF    03.5
11B6:  BSF    03.6
11B7:  MOVWF  1A
11B8:  MOVLW  96
11B9:  MOVWF  1B
11BA:  BCF    0A.4
11BB:  BCF    03.5
11BC:  BCF    03.6
11BD:  CALL   1CD
11BE:  BSF    0A.4
11BF:  BSF    03.5
11C0:  BSF    03.6
11C1:  DECFSZ 1A,F
11C2:  GOTO   1B8
....................    set_kbd_lamp(8); 
11C3:  MOVLW  08
11C4:  MOVWF  1D
11C5:  BCF    0A.4
11C6:  BCF    03.5
11C7:  BCF    03.6
11C8:  CALL   172
11C9:  BSF    0A.4
....................    delay_ms(300);  
11CA:  MOVLW  02
11CB:  BSF    03.5
11CC:  BSF    03.6
11CD:  MOVWF  1A
11CE:  MOVLW  96
11CF:  MOVWF  1B
11D0:  BCF    0A.4
11D1:  BCF    03.5
11D2:  BCF    03.6
11D3:  CALL   1CD
11D4:  BSF    0A.4
11D5:  BSF    03.5
11D6:  BSF    03.6
11D7:  DECFSZ 1A,F
11D8:  GOTO   1CE
....................    set_kbd_lamp(7); 
11D9:  MOVLW  07
11DA:  MOVWF  1D
11DB:  BCF    0A.4
11DC:  BCF    03.5
11DD:  BCF    03.6
11DE:  CALL   172
11DF:  BSF    0A.4
....................    delay_ms(300);  
11E0:  MOVLW  02
11E1:  BSF    03.5
11E2:  BSF    03.6
11E3:  MOVWF  1A
11E4:  MOVLW  96
11E5:  MOVWF  1B
11E6:  BCF    0A.4
11E7:  BCF    03.5
11E8:  BCF    03.6
11E9:  CALL   1CD
11EA:  BSF    0A.4
11EB:  BSF    03.5
11EC:  BSF    03.6
11ED:  DECFSZ 1A,F
11EE:  GOTO   1E4
....................    set_kbd_lamp(6); 
11EF:  MOVLW  06
11F0:  MOVWF  1D
11F1:  BCF    0A.4
11F2:  BCF    03.5
11F3:  BCF    03.6
11F4:  CALL   172
11F5:  BSF    0A.4
....................    delay_ms(300);  
11F6:  MOVLW  02
11F7:  BSF    03.5
11F8:  BSF    03.6
11F9:  MOVWF  1A
11FA:  MOVLW  96
11FB:  MOVWF  1B
11FC:  BCF    0A.4
11FD:  BCF    03.5
11FE:  BCF    03.6
11FF:  CALL   1CD
1200:  BSF    0A.4
1201:  BSF    03.5
1202:  BSF    03.6
1203:  DECFSZ 1A,F
1204:  GOTO   1FA
....................    set_kbd_lamp(5); 
1205:  MOVLW  05
1206:  MOVWF  1D
1207:  BCF    0A.4
1208:  BCF    03.5
1209:  BCF    03.6
120A:  CALL   172
120B:  BSF    0A.4
....................    delay_ms(300);  
120C:  MOVLW  02
120D:  BSF    03.5
120E:  BSF    03.6
120F:  MOVWF  1A
1210:  MOVLW  96
1211:  MOVWF  1B
1212:  BCF    0A.4
1213:  BCF    03.5
1214:  BCF    03.6
1215:  CALL   1CD
1216:  BSF    0A.4
1217:  BSF    03.5
1218:  BSF    03.6
1219:  DECFSZ 1A,F
121A:  GOTO   210
....................    set_kbd_lamp(4); 
121B:  MOVLW  04
121C:  MOVWF  1D
121D:  BCF    0A.4
121E:  BCF    03.5
121F:  BCF    03.6
1220:  CALL   172
1221:  BSF    0A.4
....................    delay_ms(300);  
1222:  MOVLW  02
1223:  BSF    03.5
1224:  BSF    03.6
1225:  MOVWF  1A
1226:  MOVLW  96
1227:  MOVWF  1B
1228:  BCF    0A.4
1229:  BCF    03.5
122A:  BCF    03.6
122B:  CALL   1CD
122C:  BSF    0A.4
122D:  BSF    03.5
122E:  BSF    03.6
122F:  DECFSZ 1A,F
1230:  GOTO   226
....................    set_kbd_lamp(3); 
1231:  MOVLW  03
1232:  MOVWF  1D
1233:  BCF    0A.4
1234:  BCF    03.5
1235:  BCF    03.6
1236:  CALL   172
1237:  BSF    0A.4
....................    delay_ms(300);  
1238:  MOVLW  02
1239:  BSF    03.5
123A:  BSF    03.6
123B:  MOVWF  1A
123C:  MOVLW  96
123D:  MOVWF  1B
123E:  BCF    0A.4
123F:  BCF    03.5
1240:  BCF    03.6
1241:  CALL   1CD
1242:  BSF    0A.4
1243:  BSF    03.5
1244:  BSF    03.6
1245:  DECFSZ 1A,F
1246:  GOTO   23C
....................    set_kbd_lamp(2); 
1247:  MOVLW  02
1248:  MOVWF  1D
1249:  BCF    0A.4
124A:  BCF    03.5
124B:  BCF    03.6
124C:  CALL   172
124D:  BSF    0A.4
....................    delay_ms(300);  
124E:  MOVLW  02
124F:  BSF    03.5
1250:  BSF    03.6
1251:  MOVWF  1A
1252:  MOVLW  96
1253:  MOVWF  1B
1254:  BCF    0A.4
1255:  BCF    03.5
1256:  BCF    03.6
1257:  CALL   1CD
1258:  BSF    0A.4
1259:  BSF    03.5
125A:  BSF    03.6
125B:  DECFSZ 1A,F
125C:  GOTO   252
....................    set_kbd_lamp(1); 
125D:  MOVLW  01
125E:  MOVWF  1D
125F:  BCF    0A.4
1260:  BCF    03.5
1261:  BCF    03.6
1262:  CALL   172
1263:  BSF    0A.4
....................    delay_ms(300);  
1264:  MOVLW  02
1265:  BSF    03.5
1266:  BSF    03.6
1267:  MOVWF  1A
1268:  MOVLW  96
1269:  MOVWF  1B
126A:  BCF    0A.4
126B:  BCF    03.5
126C:  BCF    03.6
126D:  CALL   1CD
126E:  BSF    0A.4
126F:  BSF    03.5
1270:  BSF    03.6
1271:  DECFSZ 1A,F
1272:  GOTO   268
....................  
....................   // set_uart_speed(9600,mp3player); 
....................  
....................   // mp3commandpush(MP3_CMD_SET_SERIAL_SPEED); 
....................    
....................    set_uart_speed(38400,mp3player); 
1273:  MOVLW  20
1274:  BCF    03.6
1275:  MOVWF  19
1276:  MOVLW  A6
1277:  MOVWF  18
....................    
....................    mp3commandpush(MP3_CMD_STOP); 
1278:  MOVLW  04
1279:  BSF    03.6
127A:  MOVWF  35
127B:  BCF    0A.4
127C:  BCF    03.5
127D:  BCF    03.6
127E:  CALL   1E1
127F:  BSF    0A.4
....................    mp3commandpush(MP3_CMD_SET_VOLUME); 
1280:  MOVLW  02
1281:  BSF    03.5
1282:  BSF    03.6
1283:  MOVWF  35
1284:  BCF    0A.4
1285:  BCF    03.5
1286:  BCF    03.6
1287:  CALL   1E1
1288:  BSF    0A.4
....................    mp3commandpush(MP3_CMD_SET_BASS_ENHANCE); 
1289:  MOVLW  11
128A:  BSF    03.5
128B:  BSF    03.6
128C:  MOVWF  35
128D:  BCF    0A.4
128E:  BCF    03.5
128F:  BCF    03.6
1290:  CALL   1E1
1291:  BSF    0A.4
....................    mp3commandpush(MP3_CMD_ENABLE_BUSY_IND); 
1292:  MOVLW  14
1293:  BSF    03.5
1294:  BSF    03.6
1295:  MOVWF  35
1296:  BCF    0A.4
1297:  BCF    03.5
1298:  BCF    03.6
1299:  CALL   1E1
129A:  BSF    0A.4
....................    mp3commandpush(MP3_CMD_LOOP_OFF); 
129B:  MOVLW  16
129C:  BSF    03.5
129D:  BSF    03.6
129E:  MOVWF  35
129F:  BCF    0A.4
12A0:  BCF    03.5
12A1:  BCF    03.6
12A2:  CALL   1E1
12A3:  BSF    0A.4
....................    
....................    random_init(); 
12A4:  BCF    0A.4
12A5:  GOTO   21A
12A6:  BSF    0A.4
....................  
....................    program_running = read_eeprom(EEPROM_RUNNING_PROGRAM); 
12A7:  MOVLW  05
12A8:  BSF    03.6
12A9:  MOVWF  0D
12AA:  BSF    03.5
12AB:  BCF    0C.7
12AC:  BSF    0C.0
12AD:  BCF    03.5
12AE:  MOVF   0C,W
12AF:  BCF    03.6
12B0:  MOVWF  2F
....................  
....................    delay_ms(100);  // wait for things to calm 
12B1:  MOVLW  64
12B2:  BSF    03.5
12B3:  BSF    03.6
12B4:  MOVWF  1B
12B5:  BCF    0A.4
12B6:  BCF    03.5
12B7:  BCF    03.6
12B8:  CALL   1CD
12B9:  BSF    0A.4
....................  
....................  
....................    program_start(program_running); 
12BA:  MOVF   2F,W
12BB:  BSF    03.5
12BC:  BSF    03.6
12BD:  MOVWF  1C
12BE:  BCF    0A.4
12BF:  BCF    03.5
12C0:  BCF    03.6
12C1:  CALL   2E1
12C2:  BSF    0A.4
....................   // program_start(4); 
....................  
....................    for (;;) { 
....................  
....................     mp3execute(); 
12C3:  BCF    0A.4
12C4:  GOTO   585
12C5:  BSF    0A.4
....................  
.................... 	if (busy_went_down) 
12C6:  BTFSS  30.7
12C7:  GOTO   2D2
.................... 	{ 
.................... 		busy_went_down = 0; 
12C8:  BCF    30.7
.................... 		mp3playing = 0; 
12C9:  BCF    30.4
.................... 		program_sample_completed(0); 
12CA:  BSF    03.5
12CB:  BSF    03.6
12CC:  CLRF   1A
12CD:  BCF    0A.4
12CE:  BCF    03.5
12CF:  BCF    03.6
12D0:  GOTO   5C8
12D1:  BSF    0A.4
.................... 	} 
....................  
.................... 	if (busy_went_up) 
12D2:  BTFSS  7E.0
12D3:  GOTO   2DD
.................... 	{ 
.................... 		busy_went_up = 0; 
12D4:  BCF    7E.0
.................... 		program_sample_started(0); 
12D5:  BSF    03.5
12D6:  BSF    03.6
12D7:  CLRF   1A
12D8:  BCF    0A.4
12D9:  BCF    03.5
12DA:  BCF    03.6
12DB:  GOTO   69A
12DC:  BSF    0A.4
.................... 	} 
....................  
....................  
....................  
....................     if (mp3completed) 
12DD:  MOVF   64,F
12DE:  BTFSC  03.2
12DF:  GOTO   2E1
....................  	{ 
....................     	mp3completed = 0; 
12E0:  CLRF   64
.................... 	} 
....................  
....................    if (queue_start != queue_stop) { 
12E1:  MOVF   3E,W
12E2:  SUBWF  3D,W
12E3:  BTFSC  03.2
12E4:  GOTO   2F8
....................      dokeyaction(queue[queue_start]); 
12E5:  MOVLW  33
12E6:  ADDWF  3D,W
12E7:  MOVWF  04
12E8:  BCF    03.7
12E9:  MOVF   00,W
12EA:  BSF    03.5
12EB:  BSF    03.6
12EC:  MOVWF  1A
12ED:  MOVWF  1B
12EE:  BCF    0A.4
12EF:  BSF    0A.3
12F0:  BCF    03.5
12F1:  BCF    03.6
12F2:  GOTO   000
12F3:  BSF    0A.4
12F4:  BCF    0A.3
....................      pop(); 
12F5:  BCF    0A.4
12F6:  GOTO   7D3
12F7:  BSF    0A.4
....................    } 
....................  
....................    if (timeout1msec) { 
12F8:  BTFSS  30.0
12F9:  GOTO   307
....................      timeout1msec = 0; 
12FA:  BCF    30.0
....................      dobuttonpush(); 
12FB:  BCF    0A.4
12FC:  BSF    0A.3
12FD:  GOTO   33D
12FE:  BSF    0A.4
12FF:  BCF    0A.3
....................  
.................... 	if (input_state(KEYLOCK) == 0) dokeyboard(); 
1300:  BTFSC  09.0
1301:  GOTO   307
1302:  BCF    0A.4
1303:  BSF    0A.3
1304:  GOTO   391
1305:  BSF    0A.4
1306:  BCF    0A.3
....................    } 
....................  
....................    if (timeout10msec) { 
1307:  BTFSS  30.1
1308:  GOTO   30A
.................... 	 timeout10msec = 0; 
1309:  BCF    30.1
....................    } 
....................  
....................    if (timeout100msec) { 
130A:  BTFSS  30.2
130B:  GOTO   32A
.................... 	 timeout100msec = 0; 
130C:  BCF    30.2
.................... 	 program_timer100msec(); 
130D:  BCF    0A.4
130E:  BSF    0A.3
130F:  GOTO   467
1310:  BSF    0A.4
1311:  BCF    0A.3
....................  
....................      if (mp3status) { 
1312:  MOVF   63,F
1313:  BTFSC  03.2
1314:  GOTO   32A
....................       if (--mp3timeout == 0) { 
1315:  DECFSZ 66,F
1316:  GOTO   32A
.................... //       fprintf(terminal,"T!"); 
....................        button_led_on(5); 
1317:  MOVLW  05
1318:  BSF    03.5
1319:  BSF    03.6
131A:  MOVWF  20
131B:  BCF    0A.4
131C:  BCF    03.5
131D:  BCF    03.6
131E:  CALL   270
131F:  BSF    0A.4
....................        mp3completed = 0; 
1320:  CLRF   64
....................        mp3bufferptr = 0; 
1321:  CLRF   62
....................        if (--mp3retries) mp3sendcommand(); 
1322:  DECF   67,F
1323:  BTFSC  03.2
1324:  GOTO   329
1325:  BCF    0A.4
1326:  CALL   443
1327:  BSF    0A.4
....................        else mp3status = MP3_STATUS_READY; 
1328:  GOTO   32A
1329:  CLRF   63
....................       } 
....................      } 
....................  
....................    } 
....................  
....................    doserial(); 
132A:  BCF    0A.4
132B:  BSF    0A.3
132C:  GOTO   515
132D:  BSF    0A.4
132E:  BCF    0A.3
....................  
....................  } 
132F:  GOTO   2C3
....................  
.................... } 
1330:  SLEEP

Configuration Fuses:
   Word  1: 3F32   HS NOWDT PUT NOPROTECT NOBROWNOUT NOLVP NOCPD NOWRT NODEBUG
